<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wtttttt天</title>
  
  <subtitle>码农的幸福生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanwt.com/"/>
  <updated>2018-06-12T02:51:28.063Z</updated>
  <id>http://fanwt.com/</id>
  
  <author>
    <name>Wtttttt天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Yogakit介绍</title>
    <link href="http://fanwt.com/2018/06/12/Yogakit%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fanwt.com/2018/06/12/Yogakit介绍/</id>
    <published>2018-06-12T02:49:32.000Z</published>
    <updated>2018-06-12T02:51:28.063Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="yogakit">YogaKit</span></h1><h2><span id="jie-shao">介绍</span></h2><p>YogaKit是Facebook开源的一个CSS3/Flexbox跨平台布局引擎。</p><h2><span id="ios-yuan-sheng-bu-ju-jian-yao-shuo-ming">iOS原生布局简要说明</span></h2><p>iOS中有2种原生布局方式+2种自动布局利器</p><table><thead><tr><th style="text-align:left">布局方式名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>绝对布局</strong></td><td style="text-align:left">声明该元素在父视图中绝对位置</td></tr><tr><td style="text-align:left"><strong>相对布局</strong></td><td style="text-align:left">声明该元素相对父视图或其他元素相对位置</td></tr></tbody></table><table><thead><tr><th style="text-align:left">自动布局名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>autoresizing</strong></td><td style="text-align:left">标记自己在父视图中的位置、以及相对父视图缩放时是否按比例缩放</td></tr><tr><td style="text-align:left"><strong>autolayout</strong></td><td style="text-align:left">标记自己相对于父视图或同级其他元素的位置、大小</td></tr></tbody></table><h3><span id="autoresizing">autoresizing</span></h3><p>autoresizing提供了7个布局枚举值，可以组合使用它们完成简单的自动布局。</p><table><thead><tr><th style="text-align:left">枚举值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>UIViewAutoresizingNone</strong></td><td style="text-align:left">不会随父视图的改变而改变</td></tr><tr><td style="text-align:left"><strong>UIViewAutoresizingFlexibleLeftMargin</strong></td><td style="text-align:left">自动调整view与父视图左边距，以保证右边距不变</td></tr><tr><td style="text-align:left"><strong>UIViewAutoresizingFlexibleWidth</strong></td><td style="text-align:left">自动调整view的宽度，保证左边距和右边距不变</td></tr><tr><td style="text-align:left"><strong>UIViewAutoresizingFlexibleRightMargin</strong></td><td style="text-align:left">自动调整view与父视图右边距，以保证左边距不变</td></tr><tr><td style="text-align:left"><strong>UIViewAutoresizingFlexibleTopMargin</strong></td><td style="text-align:left">自动调整view与父视图上边距，以保证下边距不变</td></tr><tr><td style="text-align:left"><strong>UIViewAutoresizingFlexibleHeight</strong></td><td style="text-align:left">自动调整view的高度，以保证上边距和下边距不变</td></tr><tr><td style="text-align:left"><strong>UIViewAutoresizingFlexibleBottomMargin</strong></td><td style="text-align:left">自动调整view与父视图的下边距，以保证上边距不变</td></tr></tbody></table><p>autoresizing自动布局方案的缺点很明显，它只能做简单的自动布局适配，当视觉需求复杂时，代码中将会出现大量的if else判断语句。</p><h3><span id="autolayout">autolayout</span></h3><p>autolayout是Apple在iOS6种推出的自动布局方案，给每一个UI元素都添加一套相对于父元素或同级其他元素位置、大小的约束，按照这些约束将UI元素渲染在不同分辨率下，呈现的排版是一样的。</p><p>Apple起初的想法是好的，因为这样强约束的布局方案可以有效减少UI嵌套层级，在早年硬件设备性能不是那么好的时候，这种布局方案发挥了极大的作用，但随着硬件性能不断提升，这种布局方案在性能上的优势越来越不明显。</p><p>autolayout最大的问题在于程序员需要精确的知道每一个UI元素的约束关系，当页面约束很复杂的时候，对程序员的细心和耐心是极大的考验。然而这根本不算是最严重的问题，一般页面都由若干个组件拼装而成，autolayout最可怕的是不支持热插拔组件，即不可以销毁一个有其他组件依赖该组件约束的组件，程序员如果想要“删除”一个组件，需要添加一个引用指向该组件的宽或高，当需要“删除”时，将该变量设为0，你以为就这么简单的完了？如果再将该组件“插入”回原处呢？</p><h2><span id="flexbox-jie-jue-liao-shi-me">Flexbox解决了什么？</span></h2><blockquote><ul><li>方向性 （传统布局方向是从左到右，从上至下）</li><li>弹性伸缩 （传统尺寸定义是通过像素等来精确定义）</li><li>元素对齐（可以做到插拔）</li></ul></blockquote><p>从上述几点看来，它似乎完美的解决了iOS原生布局开发效率低的问题，但它会增加页面的嵌套层级关系，在硬件性能饱和的情况下用空间换取开发效率。</p><h2><span id="flexbox-ji-ben-gai-nian">Flexbox基本概念</span></h2><p>如果元素采用Flex进行布局，那么这个元素就可以称为Flex容器（Flex container），元素的所有子元素称为Flex项目（Flex item）。</p><p>下图为Flexbox模型图：<br><img src="http://yangjh.oschina.io/front-end/images/CSS3-Flexbox-Model.jpg" alt="Alt text"></p><h3><span id="ji-ge-zhu-yu">几个术语</span></h3><blockquote><ul><li>main axis：水平主轴</li><li>main-start：主轴开始位置，与边框的交叉点</li><li>main-end：主轴的结束位置</li><li>cross axis：垂直交叉轴</li><li>cross-start：交叉轴的开始位置</li><li>cross-end：交叉轴的结束位置</li><li>main size：单个项目占据的主轴空间</li><li>cross size：单个项目占据的交叉轴空间</li></ul></blockquote><h2><span id="zai-ios-duan-shi-yong-yogakit-bu-ju">在iOS端使用YogaKit布局</span></h2><p>将一个View开启yoga布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view configureLayoutWithBlock:^(YGLayout *_Nonnull layout) &#123;</span><br><span class="line">    layout.isEnabled = YES;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h3><span id="flexdirection">flexDirection</span></h3><p>在yoga中，API将所有Flexbox样式属性中的中划线去掉，例如flex-direction改为flexDirection。</p><p>flexDirection属性决定主轴的方向（即item的排列方向）。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">yoga枚举名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>column</strong></td><td style="text-align:left">YGFlexDirectionColumn</td><td style="text-align:left">UIView默认值，主轴为垂直方向</td></tr><tr><td style="text-align:left"><strong>columnReverse</strong></td><td style="text-align:left">YGFlexDirectionColumnReverse</td><td style="text-align:left">主轴为垂直方向，起点在底部</td></tr><tr><td style="text-align:left"><strong>row</strong></td><td style="text-align:left">YGFlexDirectionRow</td><td style="text-align:left">主轴为水平方向</td></tr><tr><td style="text-align:left"><strong>rowReverse</strong></td><td style="text-align:left">YGFlexDirectionRowReverse</td><td style="text-align:left">主轴为水平方向，起点在右端</td></tr></tbody></table><p><img src="http://yangjh.oschina.io/front-end/images/flex-direction-row.png" alt="Alt text"><br>主轴为水平方向，起点在左端</p><p><img src="http://yangjh.oschina.io/front-end/images/flex-direction-row-reverse.png" alt="Alt text"><br>主轴为水平方向，起点在右端</p><p><img src="http://yangjh.oschina.io/front-end/images/flex-direction-column.png" alt="Alt text"><br>主轴为垂直方向，起点在上端</p><p><img src="http://yangjh.oschina.io/front-end/images/flex-direction-column-reverse.png" alt="Alt text"><br>主轴为垂直方向，起点在下端</p><h3><span id="flexwrap">flexWrap</span></h3><p>flexWrap属性决定内容在抽线上排列不下的换行方式。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">yoga枚举名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>nowrap</strong></td><td style="text-align:left">YGWrapNoWrap</td></tr><tr><td style="text-align:left"><strong>wrap</strong></td><td style="text-align:left">YGWrapWrap</td></tr><tr><td style="text-align:left"><strong>wrapReverse</strong></td><td style="text-align:left">YGWrapWrapReverse</td></tr></tbody></table><p><strong>父容器按行排列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[view configureLayoutWithBlock:^(YGLayout *_Nonnull layout) &#123;</span><br><span class="line">    layout.isEnabled = YES;</span><br><span class="line">    layout.direction = YGFlexDirectionRow;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p><img src="http://yangjh.oschina.io/front-end/images/flex-wrap-nowrap.png" alt="Alt text"><br>nowrap不换行</p><p><img src="http://yangjh.oschina.io/front-end/images/flex-wrap-wrap.png" alt="Alt text"><br>wrap换行</p><p><img src="http://yangjh.oschina.io/front-end/images/flex-wrap-wrap-reverse.png" alt="Alt text"><br>wrapReverse，起点在主轴底部</p><h3><span id="justifycontent">justifyContent</span></h3><p>justifyContent属性定义项目在主轴上的对齐方式。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">yoga枚举名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>start</strong></td><td style="text-align:left">YGJustifyFlexStart</td><td style="text-align:left">左对齐</td></tr><tr><td style="text-align:left"><strong>center</strong></td><td style="text-align:left">YGJustifyCenter</td><td style="text-align:left">居中</td></tr><tr><td style="text-align:left"><strong>end</strong></td><td style="text-align:left">YGJustifyFlexEnd</td><td style="text-align:left">右对齐</td></tr><tr><td style="text-align:left"><strong>spaceBetween</strong></td><td style="text-align:left">YGJustifySpaceBetween</td><td style="text-align:left">两端对齐，item之间的间隔相等</td></tr><tr><td style="text-align:left"><strong>spaceAround</strong></td><td style="text-align:left">YGJustifySpaceAround</td><td style="text-align:left">每个item两侧的间隔相等</td></tr><tr><td style="text-align:left"><strong>spaceEvenly</strong></td><td style="text-align:left">YGJustifySpaceEvenly</td><td style="text-align:left">左右边距和每个item之间的间隔一致</td></tr></tbody></table><p><strong>父容器按行排列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[view configureLayoutWithBlock:^(YGLayout *_Nonnull layout) &#123;</span><br><span class="line">    layout.isEnabled = YES;</span><br><span class="line">    layout.direction = YGFlexDirectionRow;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p><img src="http://yangjh.oschina.io/front-end/images/justify-content-flex-start.png" alt="Alt text"><br>start，左对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/justify-content-center.png" alt="Alt text"><br>center，居中</p><p><img src="http://yangjh.oschina.io/front-end/images/justify-content-flex-end.png" alt="Alt text"><br>end，右对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/justify-content-space-between.png" alt="Alt text"><br>spaceBetween，两端对齐，item之间的间隔相等</p><p><img src="http://yangjh.oschina.io/front-end/images/justify-content-space-around.png" alt="Alt text"><br>spaceAround，每个item两侧的间隔相等</p><p><img src="https://s1.ax1x.com/2018/06/11/CqXnmR.png" alt="Alt text"><br>spaceEvenly，左右边距和每个item之间的间隔一致</p><h3><span id="alignitems">alignItems</span></h3><p>align-items属性定义项目在交叉轴上的对齐方式。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">yoga枚举名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>flexStart</strong></td><td style="text-align:left">YGAlignFlexStart</td><td style="text-align:left">交叉轴的起点对齐</td></tr><tr><td style="text-align:left"><strong>flexEnd</strong></td><td style="text-align:left">YGAlignFlexEnd</td><td style="text-align:left">交叉轴的终点对齐</td></tr><tr><td style="text-align:left"><strong>center</strong></td><td style="text-align:left">YGAlignCenter</td><td style="text-align:left">交叉轴的中点对齐</td></tr><tr><td style="text-align:left"><strong>baseline</strong></td><td style="text-align:left">YGAlignBaseline</td><td style="text-align:left">项目的第一行文字的基线对齐</td></tr><tr><td style="text-align:left"><strong>stretch</strong></td><td style="text-align:left">YGAlignStretch</td><td style="text-align:left">如果项目未设置高度或设为auto，将占满整个容器的高度</td></tr></tbody></table><p><strong>父容器按行排列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[view configureLayoutWithBlock:^(YGLayout *_Nonnull layout) &#123;</span><br><span class="line">    layout.isEnabled = YES;</span><br><span class="line">    layout.direction = YGFlexDirectionRow;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p><img src="http://yangjh.oschina.io/front-end/images/align-items-flex-start.png" alt="Alt text"><br>flexStart，交叉轴的起点对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/align-items-flex-end.png" alt="Alt text"><br>flexEnd，交叉轴的终点对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/align-items-center.png" alt="Alt text"><br>center，交叉轴的中点对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/align-items-baseline.png" alt="Alt text"><br>baseline，项目的第一行文字的基线对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/align-items-stretch.png" alt="Alt text"><br>stretch，如果项目未设置高度或设为auto，将占满整个容器的高度</p><h3><span id="aligncontent">alignContent</span></h3><p>align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">yoga枚举名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>flexStart</strong></td><td style="text-align:left">YGAlignFlexStart</td><td style="text-align:left">与交叉轴的起点对齐</td></tr><tr><td style="text-align:left"><strong>flexEnd</strong></td><td style="text-align:left">YGAlignFlexEnd</td><td style="text-align:left">与交叉轴的终点对齐</td></tr><tr><td style="text-align:left"><strong>center</strong></td><td style="text-align:left">YGAlignCenter</td><td style="text-align:left">与交叉轴的中点对齐</td></tr><tr><td style="text-align:left"><strong>spaceBetween</strong></td><td style="text-align:left">YGJustifySpaceBetween</td><td style="text-align:left">与交叉轴两端对齐，轴线之间的间隔平均分布</td></tr><tr><td style="text-align:left"><strong>spaceAround</strong></td><td style="text-align:left">YGJustifySpaceAround</td><td style="text-align:left">每根轴线两侧的间隔都相等</td></tr><tr><td style="text-align:left"><strong>stretch</strong></td><td style="text-align:left">YGAlignStretch</td><td style="text-align:left">轴线占满整个交叉轴</td></tr></tbody></table><p><strong>父容器按行排列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[view configureLayoutWithBlock:^(YGLayout *_Nonnull layout) &#123;</span><br><span class="line">    layout.isEnabled = YES;</span><br><span class="line">    layout.direction = YGFlexDirectionRow;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p><img src="http://yangjh.oschina.io/front-end/images/align-content-flex-start.png" alt="Alt text"><br>flexStart，与交叉轴的起点对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/align-content-flex-end.png" alt="Alt text"><br>flexEnd，与交叉轴的终点对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/align-content-center.png" alt="Alt text"><br>center，与交叉轴的中点对齐</p><p><img src="http://yangjh.oschina.io/front-end/images/align-content-space-between.png" alt="Alt text"><br>spaceBetween，与交叉轴两端对齐，轴线之间的间隔平均分布</p><p><img src="http://yangjh.oschina.io/front-end/images/align-content-space-around.png" alt="Alt text"><br>spaceAround，每根轴线两侧的间隔都相等</p><p><img src="http://yangjh.oschina.io/front-end/images/align-content-stretch.png" alt="Alt text"><br>stretch，轴线占满整个交叉轴</p><h3><span id="flexgrow">flexGrow</span></h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><p><strong>父容器按行排列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[view configureLayoutWithBlock:^(YGLayout *_Nonnull layout) &#123;</span><br><span class="line">    layout.isEnabled = YES;</span><br><span class="line">    layout.direction = YGFlexDirectionRow;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p><img src="http://yangjh.oschina.io/front-end/images/flex-grow.png" alt="Alt text"><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</p><h3><span id="flexshrink">flexShrink</span></h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><strong>父容器按行排列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[view configureLayoutWithBlock:^(YGLayout *_Nonnull layout) &#123;</span><br><span class="line">    layout.isEnabled = YES;</span><br><span class="line">    layout.direction = YGFlexDirectionRow;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p><img src="http://yangjh.oschina.io/front-end/images/flex-shrink.png" alt="Alt text"><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p><h3><span id="alignself">alignSelf</span></h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><h3><span id="flexbasis">flexBasis</span></h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;yogakit&quot;&gt;YogaKit&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;jie-shao&quot;&gt;介绍&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;YogaKit是Facebook开源的一个CSS3/Flexbox跨平台布局引擎。&lt;/p&gt;
&lt;h2&gt;&lt;span i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2017总结</title>
    <link href="http://fanwt.com/2018/01/23/2017%E6%80%BB%E7%BB%93/"/>
    <id>http://fanwt.com/2018/01/23/2017总结/</id>
    <published>2018-01-23T14:08:07.000Z</published>
    <updated>2018-01-23T15:35:41.411Z</updated>
    
    <content type="html"><![CDATA[<p>2017年匆匆地进入了年底，一边听着轻盈的日漫歌曲，脑袋里不断闪过这一年所发生的总总，不得不说，真的很感激这一年让我见了很多世面，通过一次次的摔倒、爬起、前进，从中沉淀积累了诸多宝贵的经验，在这过程中心态逐渐的转变和调整是件非常有意思的事。</p><ul><li><p>生活<br>不同的人对生活的理解和看法不一样，个人非常喜欢安静的环境，家就是栖息生活、学习、工作的地方，对此我要求非常高，希望一点一滴都是自己设计和动工完成，于是…<br>今年我仍旧在独自奋战装修，嗯，是的，还在装修ing（PS：2016年我就在动工了），目前看进度非常有可能会持续到2018年5月左右。很多人问自己装修不累吗？工作赚那么多为啥还要自己装呢？嗯，不同的人对生活的理解和看法不一样，人这辈子很短也很长，我希望能经历更多有意思的东西，还在我年少的时候（哈哈哈哈哈😄）。装修那么大的工程，怎么能不累，从最初的铲墙时就体会到了装修师傅的心酸，整个房间要喷水，然后拿铲刀一点点的铲墙皮，铲下来的旧腻子装了应该有十袋蛇皮袋。到后来的刮腻子，一站就是一整天，批刀、铲子刮一天墙，打磨更是灰大到整个房间都是灰蒙蒙的，有时候真的是累到腰都直不起来，手臂也抬不动，晚上睡着后手指就像埋在了混泥土里僵硬的动不了。苦归苦，从中感悟了许多平常当码农时感受不到的道理，生活不易，且行且珍惜，好好地活在当下。<br>衣食行这些日常开销几乎没有变化，不过爱上了坐地铁，嗯，原因是多出来的时间可以用来背单词。</p></li><li><p>学习<br>学到老活到老嘛<br>17年自学能力提升很大，可以一天从早自修到深夜，这一点在我上学的时候都没有过，这样自觉自学考完了许多课程，其中对高数和英语的成绩很满意。<br>18年希望勇敢的参加研究生考试，不管考多少分，至少这辈子不留遗憾。</p></li><li><p>工作<br>参与3个大型项目的核心开发，完成6个SDK的编写，开源了1个个人SDK。<br>参与的项目更多，见识的知识面更加广了，感谢公司有这么好的一个平台得以付出无限的精力和热情。</p></li></ul><p>2018年<br>一个温馨的家<br>一张录取通知书<br>一份很nice的绩效成绩单<br>加油2018！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年匆匆地进入了年底，一边听着轻盈的日漫歌曲，脑袋里不断闪过这一年所发生的总总，不得不说，真的很感激这一年让我见了很多世面，通过一次次的摔倒、爬起、前进，从中沉淀积累了诸多宝贵的经验，在这过程中心态逐渐的转变和调整是件非常有意思的事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS端集成RN以及踩坑</title>
    <link href="http://fanwt.com/2018/01/04/iOS%E7%AB%AF%E9%9B%86%E6%88%90RN%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%9D%91/"/>
    <id>http://fanwt.com/2018/01/04/iOS端集成RN以及踩坑/</id>
    <published>2018-01-04T02:41:54.000Z</published>
    <updated>2018-01-04T07:26:54.470Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="zhun-bei-gong-zuo">准备工作</span></h2><h3><span id="da-jian-kai-fa-huan-jing">搭建开发环境</span></h3><h4><span id="an-zhuang-homebrew">安装Homebrew</span></h4><p>Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”</span><br></pre></td></tr></table></figure></p><h4><span id="an-zhuang-node">安装Node</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><h4><span id="an-zhuang-yarn-react-native-de-ming-ling-xing-gong-ju">安装Yarn、React Native的命令行工具</span></h4><p>Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。<br>React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn react-native-cli</span><br></pre></td></tr></table></figure></p><h4><span id="an-zhuang-watchman">安装Watchman</span></h4><p>Watchman是由Facebook提供的监视文件系统变更的工具。<br>安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install watchman</span><br></pre></td></tr></table></figure></p><h4><span id="an-zhuang-flow">安装Flow</span></h4><p>Flow是一个静态的JS类型检查工具。译注：你在很多示例中看到的奇奇怪怪的冒号问号，以及方法参数中像类型一样的写法，都是属于这个flow工具的语法。这一语法并不属于ES标准，只是Facebook自家的代码规范。所以新手可以直接跳过（即不需要安装这一工具，也不建议去费力学习flow相关语法）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flow</span><br></pre></td></tr></table></figure></p><p>安装cococapods：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p><h3><span id="yuan-you-xiang-mu-ji-cheng-rn">原有项目集成RN</span></h3><h4><span id="cocoapods">Cocoapods</span></h4><p>在Podfile中添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rn_path = &apos;../node_modules/react-native&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;yoga&apos;, path: &quot;#&#123;rn_path&#125;/ReactCommon/yoga/yoga.podspec&quot;</span><br><span class="line">pod &apos;React&apos;, path: rn_path, subspecs: [</span><br><span class="line">  &apos;Core&apos;,</span><br><span class="line">  &apos;RCTActionSheet&apos;,</span><br><span class="line">  &apos;RCTAnimation&apos;,</span><br><span class="line">  &apos;RCTGeolocation&apos;,</span><br><span class="line">  &apos;RCTImage&apos;,</span><br><span class="line">  &apos;RCTLinkingIOS&apos;,</span><br><span class="line">  &apos;RCTNetwork&apos;,</span><br><span class="line">  &apos;RCTSettings&apos;,</span><br><span class="line">  &apos;RCTText&apos;,</span><br><span class="line">  &apos;RCTVibration&apos;,</span><br><span class="line">  &apos;RCTWebSocket&apos;,</span><br><span class="line">  &apos;BatchedBridge&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3><span id="xin-xiang-mu-ji-cheng-rn">新项目集成RN</span></h3><p>使用react-native命令工具创建新工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init AwesomeProject</span><br></pre></td></tr></table></figure></p><h2><span id="xiang-mu-qi-dong-qian-de-yi-huo-dian">项目启动前的疑惑点</span></h2><ol><li><p>谁来做容器？</p></li><li><p>Native跳转RN、RN跳转Native<br>客户端作为容器</p><ul><li>Native跳转RN，在初始化RctRootView时带入参数指定子页面</li><li>RN跳转Native，调用bridge中约定好的扩展方法<br>RN作为容器</li><li>Native跳转RN，调用bridge中约定好的扩展方法</li><li>RN跳转Native，RN内部处理 或 调用bridge中约定好的扩展方法</li></ul></li></ol><ol><li><p>Native调用RN、RN调用Native<br>Native调用RN</p><ul><li>初始化RCTRootView时，可以传参指定加载页面</li><li>给RN发送广播通知</li><li>扩展组件，组件中事件回调传参给RN</li></ul><p>RN调用Native</p><ul><li>Native通过实现RCTBridgeModule添加扩展</li></ul></li><li><p>js.bundle包过大，加载速度慢，导致用户可见白屏问题，如何解决？<br>分包加载解决，原理很简单：先加载重要的部分，后加载优先级低的部分</p></li><li><p>Native和RN约定数据接口以什么方式输出<br>以json格式通信</p></li><li><p>Native提供哪些基础能力给到RN</p><ul><li>open、close</li><li>fetch、upload、download（灵活，可设置header、cookies）</li><li>webview、JSSDK</li><li>扩展组件，譬如：书架、选择相册、图片展示、保存图片</li><li>各种广播通知，譬如：登录回调</li><li>设备信息等</li><li>Debug工具</li></ul></li><li><p>路由协议</p><ul><li>参考RESTful接口规范</li><li>小写开头，驼峰写法，使用下杠_，不使用中杠-</li></ul></li><li><p>热更新<br>未做</p></li></ol><h2><span id="cai-guo-de-keng">踩过的坑</span></h2><p>一、源<br>由于qiang，很多库都需要**才可以下载的到，所以国内的很多教程都是教大家切换源来解决不能下载的问题。<br>譬如切换npm源为淘宝镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure></p><p>我遇到过boost库淘宝镜像不全的问题，导致RN无法正常编译。<br>解决办法：删除本地错误boost库，还原源重新下载。</p><p>二、RN缓存</p><p>当切换不同的RN项目后，由于RN有缓存，导致RN服务无法启动，用以下命令清除缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn start --reset-cache</span><br><span class="line">// OR</span><br><span class="line">npm start -- -- reset-cache</span><br></pre></td></tr></table></figure></p><p>三、谁做容器</p><p>客户端作为容器</p><ol><li>多个RN（各自独立bridge）页面，开启Chrome Debug模式时，会因为端口被占用，导致红屏。</li><li>多个RN（共享bridge）页面，JS端错误导致页面同步，误以为由bridge生成出的RNView会同步显示。</li><li>多个RN页面会导致前端同学不好控制页面的状态切换。</li></ol><p>RN作为容器</p><ol><li>window.rootViewController发生改变，更改为UINavigationController。书架View将作为标签的形式提供给前端使用，由于RN作为容器，容器环境不可知，所以将书架Controller单独放到一个新的UINavigationController中。这种UINavigationController嵌套在以往的开放中几乎没用过，存在一定的风险。</li><li>当RN页加载不出来时，即容器初始化失败时，整个APP都无法显示。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;zhun-bei-gong-zuo&quot;&gt;准备工作&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;da-jian-kai-fa-huan-jing&quot;&gt;搭建开发环境&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span id=&quot;an-zhuang-homebrew&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS11中UITableViewCell不能侧滑编辑的诡异问题</title>
    <link href="http://fanwt.com/2017/12/08/iOS11%E4%B8%ADUITableViewCell%E4%B8%8D%E8%83%BD%E4%BE%A7%E6%BB%91%E7%BC%96%E8%BE%91%E7%9A%84%E8%AF%A1%E5%BC%82%E9%97%AE%E9%A2%98/"/>
    <id>http://fanwt.com/2017/12/08/iOS11中UITableViewCell不能侧滑编辑的诡异问题/</id>
    <published>2017-12-08T07:32:01.000Z</published>
    <updated>2017-12-08T07:53:27.503Z</updated>
    
    <content type="html"><![CDATA[<p>组员反馈项目中有一个诡异的问题，在iOS11中，工程中所有页面的UITableViewCell第一次能侧滑编辑，只要停留在该页面，之后再也无法侧滑编辑，但是仍旧能断点到代理方法中。<br>当时第一反应是怀疑工程中大量的Swizzle方法，庞大的工程也不知从何查起，抱着运行项目看看日志提示，碰碰运气的心态run了项目跑在模拟器中，在第一次侧滑编辑时无异样，滚屏退出编辑态，第二次侧滑时，tableview就无法应了，但好在日志中发现了痕迹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;prepareWithSwipeDirection:configuration:&apos;.  Signature thinks it does not return a struct, and compiler thinks it does.</span><br></pre></td></tr></table></figure></p><p>大致意思是方法签名描述不一致，也就是约定返回一个struct的，但并没有返回struct类型。</p><p>习惯性的去Google上查找资料发现<a href="https://github.com/Desgard/iOS-Source-Probe/blob/master/Objective-C/Runtime/objc_msgSend%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.md" target="_blank" rel="noopener">链接</a><br>在其中找到了__forwarding__的分析代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">if (signatureIsStret != isStret) &#123;</span><br><span class="line">    CFLog(kCFLogLevelWarning ,</span><br><span class="line">      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</span><br><span class="line">      selName,</span><br><span class="line">      signatureIsStret ? &quot;&quot; : not,</span><br><span class="line">      isStret ? &quot;&quot; : not);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更加怀疑是项目中swizzle的方法惹的祸了</p><p>怀疑的步骤为：</p><ol><li>先怀疑NSObject的methodSignatureForSelector方法，屏蔽掉工程中Swizzle的代码，发现并没解决问题。</li><li>怀疑之前解决数组和字典的nil问题，屏蔽掉所有数组和字典的swizzle方法，发现问题解决。</li><li>一个个大块放开代码检查，最终定位。</li></ol><p>罪魁祸首：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSMutableDictionary (NilSafe)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = NSClassFromString(@&quot;__NSDictionaryM&quot;);</span><br><span class="line">        [class gl_swizzleMethod:@selector(setObject:forKeyedSubscript:) withMethod:@selector(gl_setObject:forKeyedSubscript:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)gl_setObject:(id)obj forKeyedSubscript:(id&lt;NSCopying&gt;)key &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!obj) &#123;</span><br><span class="line">        obj = [NSNull null];</span><br><span class="line">    &#125;</span><br><span class="line">    [self gl_setObject:obj forKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>拦截了系统的字典，将obj为nil时替换成了NSNull，怀疑是组员从网上拷贝的代码来解决服务端下发数据中有nil的问题。如果是为了解决数组、字典中nil数据导致的crash问题，那判断到!obj时，直接return就好了。</p><p>最终解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!obj) &#123;</span><br><span class="line">    obj = [NSNull null];</span><br><span class="line">&#125;</span><br><span class="line">// 更改为</span><br><span class="line">if (!obj) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>个人觉得NSNull尽量少用，它一般用在闭环逻辑的代码中，也就是自己能掌控的闭环逻辑中，用它来标记、处理空逻辑行为。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组员反馈项目中有一个诡异的问题，在iOS11中，工程中所有页面的UITableViewCell第一次能侧滑编辑，只要停留在该页面，之后再也无法侧滑编辑，但是仍旧能断点到代理方法中。&lt;br&gt;当时第一反应是怀疑工程中大量的Swizzle方法，庞大的工程也不知从何查起，抱着运行项
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>制作OC与Swift混编的动态framework</title>
    <link href="http://fanwt.com/2017/12/06/%E5%88%B6%E4%BD%9COC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96%E7%9A%84%E5%8A%A8%E6%80%81framework/"/>
    <id>http://fanwt.com/2017/12/06/制作OC与Swift混编的动态framework/</id>
    <published>2017-12-06T07:47:27.000Z</published>
    <updated>2017-12-08T02:42:40.004Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="zhi-zuo-oc-yu-swift-hun-bian-de-dong-tai-framework">制作OC与Swift混编的动态framework</span></h1><p>在iOS开发过程中，会遇到如下场景：</p><ol><li>编写私有库。</li><li>私有库对内开放，对外需要打包成framework或static library。</li></ol><p>注：制作Swift库需是动态framework，本篇介绍都针对framework来展开讨论。</p><p>在Cocoapods还未出现之前，开发都是使用Xcode来手动创建库工程，这种方式较原始且复杂，工程接入源码和framework来调试的步骤太多，不易管理和维护。<br>Cocoapods的出现帮助了开发者管理和创建依赖库，它简单易用，只需要简单的命令和配置就能导入第三方库，或是创建一个带有Demo且带有单元测试的库工程，这样便利的依赖库管理工具极大地提升了开发者的开发效率。</p><p>本文将介绍使用Cocoapods来制作OC与Swift的动态framework。<br>（Cocoapods有一个cocoapods-packager工具，需额外地安装，但实际使用中发现它不是这么的简单易用。）</p><p>以WtCore库工程来举例，打开WtCore.xcworkspace，工程目录结构如下：<br><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512541980320.png" width="50%" height="50%"><br>command+B编译好后，可以右键Show in Finder找到WtCore.framework，目录结构如下：<br><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512542299702.png" width="100%" height="100%"></p><ul><li>Debug-iphoneos是真机的动态framework</li><li>Debug-iphonesimulator是模拟器的动态framework</li></ul><p>将这2个framework合并成一个framework，同时对模拟器和真机进行支持。<br>拷贝这2个framework至tmp目录中，结构如下：<br><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512542727585.png" width="100%" height="100%"></p><p>打开终端，进入到tmp路径下，执行以下命令来合并生成执行文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -create ./Debug-iphoneos/WtCore.framework/WtCore ./Debug-iphonesimulator/WtCore.framework/WtCore -output WtCore</span><br></pre></td></tr></table></figure></p><p>执行完后会在tmp目录中生成合并后的WtCore执行文件，可以使用如下命令查看可执行文件支持的架构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -info WtCore.framework/WtCore</span><br></pre></td></tr></table></figure></p><p><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512543011293.png" width="100%" height="100%"></p><p>合并完可执行文件后，继续执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -a Debug-iphoneos/WtCore.framework ./</span><br><span class="line">$ mv -f WtCore WtCore.framework/WtCore</span><br><span class="line">$ cp -a Debug-iphonesimulator/WtCore.framework/Modules/WtCore.swiftmodule/* WtCore.framework/Modules/WtCore.swiftmodule</span><br></pre></td></tr></table></figure></p><p>此时tmp下的WtCore.framework就是我们要的OC与Swift混编动态framework，该framework依赖的第三方库并未打包到库中，第三方使用时需要额外导入，可以README.md中说明，或是使用Cocoapods来配置该framework的第三方依赖关系。</p><p>这种制作OC与Swift混合动态framework同样适用于制作独立OC或独立Swift的库工程。<br>最后附上<a href="https://github.com/JaonFanwt/OCTestCoreFramework" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;zhi-zuo-oc-yu-swift-hun-bian-de-dong-tai-framework&quot;&gt;制作OC与Swift混编的动态framework&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在iOS开发过程中，会遇到如下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写私
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从Delegate到DelegateBlock</title>
    <link href="http://fanwt.com/2017/08/04/%E4%BB%8EDelegate%E5%88%B0DelegateBlock/"/>
    <id>http://fanwt.com/2017/08/04/从Delegate到DelegateBlock/</id>
    <published>2017-08-04T15:42:00.000Z</published>
    <updated>2017-12-06T07:58:14.773Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="cong-delegate-dao-delegateblock">从Delegate到DelegateBlock</span></h1><p>在iOS开发中常与各种delegate打交道，这种代理委托协议的开发模式学习成本很低且扩展性特别强，本文就将在delegate开发模式的基础上进一步扩展它，从Delegate转换到DelegateBlock的模式。</p><p><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_0.png" alt="Alt text"></p><p>用一张图来展示这种Delegate转换到DelegateBlock的对比：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_1.png" alt="Alt text"></p><p>改造前，实现协议的步骤如下：</p><ol><li>在类名后标记协议名。</li><li>在类中添加并实现委托协议方法。</li></ol><p>扩展后，实现协议的步骤如下：</p><ol><li>创建一个DelegateBlock代理对象。</li><li>代理对象绑定委托协议selector与block。</li></ol><p>从上述可看出改造前后有一点很大的区别：改造后的委托协议绑定方法是可以替换的，而改造前在类中添加方法的这种就只能用继承或者动态替换方法的办法来替换对应的逻辑的，什么？没看懂？举个栗子：你写了一个代理对应的若干委托方法实现，该段代码将在项目内很多地方被使用，但是有几处将会在某一个或几个委托方法有完全不一样的处理逻辑，如果用传统的delegate处理逻辑，那就需要继承类重写委托方法了，如果有一个对象，能和设置属性一样方便的设置一个block与select的mapping关系，当委托方法被调用时，替换成执行block，那就能轻松解决这个代码重用问题。</p><p>什么？还是没看懂？用代码吧：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_2.png" alt="Alt text"></p><p>PS：WtDelegateProxy类的灵感来至于RACDelegateProxy。</p><p>WtDelegateProxy类只支持一个协议（代码结构更清晰），它有一个绑定selector与block的方法，当绑定完后，delegate调用selector时，会触发消息转发行为，将在内部执行block方法，从而实现delegate到delegateBlock的转换。</p><p>流程如图所示：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_3.png" alt="Alt text"></p><p>它能干什么呢？<br>先来看一下iOS端开发最为常见的一个UI组建：UITableView，UITableView是Apple提供的UI滚动单元格控件，可以说是iOS开发中使用频率最高的控件，日常使用的APP诸如QQ、微信、网易新闻等软件中大量使用了该控件，它能给用户带来极佳的用户体验。</p><p>UITableView的性能极高，提供给开发者的API也非常容易上手，它提供了UITableViewDataSource和UITableViewDelegate两个代理类，前者是数据源代理，UITableView会从它委托的代理方法中获取数据，后者是一般代理，UITableView的生命周期事件以及交互事件等都会回调到它委托的代理方法。</p><p>通常UITableView中只有一种Cell类型的时候，代码会特别的简洁和清晰，一旦Cell类型巨增的时候，委托代理方法中的逻辑将变得十分可怕，看看如下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span> (indexPath.section == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexPath.row == <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (indexPath.row == <span class="number">1</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (indexPath.section == <span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>项目中这样的需求并不少见，就拿起点读书APP来说，诸如：精选页、书籍详情页、账户页。如果TableView中的cell出现组合策略的话，其中的逻辑会变的更加复杂，使用上述的这种判断indexPath的办法显得十分笨拙以及难以维护，甚至一不小心就会出现数据源与UI刷新不一致从而导致崩溃。</p><p>接下来一起来看看如何从容优雅地使用它来实现UITableView，改造后：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_4.png" alt="Alt text"></p><p>流程如下：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_5.png" alt="Alt text"></p><p>也就是将TableView的数据源由Model换为ViewModel，ViewModel只干一件事：双向数据绑定！UIViewController中的代理方法也只干一件事：取出ViewModel，然后调用对应的代理方法。</p><p>在ViewModel中绑定对应协议委托方法，这些方法有对应的Cell如何创建、多高、点击事件、3DTouch重压事件，该ViewModel可以提供给组内其他开发人员使用，只需要设置一些数据字段，就可以简单的展示在TableView上，如果你需要一个不一样的点击事件，可以将ViewModel中的delegate对象重新设置selector与block的绑定关系即可。</p><p>最后<a href="https://github.com/JaonFanwt/WtCellModel" target="_blank" rel="noopener">Demo地址</a>奉上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;cong-delegate-dao-delegateblock&quot;&gt;从Delegate到DelegateBlock&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在iOS开发中常与各种delegate打交道，这种代理委托协议的开发模式学习成本很低且扩展性特别强，本文就将在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Shadowsocks科学上网</title>
    <link href="http://fanwt.com/2017/07/02/%E4%BD%BF%E7%94%A8Shadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://fanwt.com/2017/07/02/使用Shadowsocks科学上网/</id>
    <published>2017-07-02T15:28:18.000Z</published>
    <updated>2017-07-02T15:40:59.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jian-jie">简介</a></li><li><a href="#zhi-shi-dian">知识点</a></li><li><a href="#vultr-shadowsocks-tcpspeed-fen-bie-shi-shi-me">Vultr + Shadowsocks + tcpspeed 分别是什么？</a></li><li><a href="#kai-xiao">开销</a></li><li><a href="#vultr-jia-de-vps">Vultr家的VPS</a><ul><li><a href="#zhu-ce-vultr-zhang-hao">注册Vultr账号</a></li></ul></li><li><a href="#macos-shang-an-zhuang-shadowsocks-ke-hu-duan">macOS上安装Shadowsocks客户端</a></li><li><a href="#tcpspeed-gou-mai-vultr-fu-wu-duan-bu-shu">tcpspeed购买 + Vultr服务端部署</a></li><li><a href="#hui-dao-macos-she-zhi-tcpspeed-ke-hu-duan">回到macOS设置tcpspeed客户端</a></li></ul><!-- tocstop --><p></div></p><h2><span id="jian-jie">简介</span></h2><p>码农一枚<br>工作所需，许多技术问题在Google上一查便知，大大地帮助了我解决各种技术疑难杂症<br>Gmail，个人觉得最最最好用的邮箱，但国内经常无法登录<br>偶尔上下油管、tumblr小小的怡情一下，速度嘛要求必须高，时间便是金钱~</p><p>尝试过购买商家VPN，也中转过几家，总结有以下几个缺点：</p><ol><li>价格贵。</li><li>有流量限制，流量越高，价格越高。</li><li>不稳定，看油管1080P跑不动。</li><li>连接设备数量限制。</li><li>商家说不定哪天就跑路啦，哈哈。</li></ol><p>在查询了各种资料后，最终选择了以下组合方案：<br>Vultr + Shadowsocks + tcpspeed</p><p>该组合能将带宽利用最大化，看油管、tumblr高清视频毫无压力。</p><h2><span id="zhi-shi-dian">知识点</span></h2><p>看完本篇文章，你将学会以下技能：</p><ol><li>注册并购买VPS（推荐Vultr，便宜量又足）。</li><li>在VPS上创建CentOS 7系统，安装Shadowsocks服务端，设置并开启Shadowsocks服务。</li><li>在macOS上安装Shadowsocks客户端，设置并使用。</li><li>为了全速利用带宽，购买tcpspeed，在CentOS上安装服务端，并在macOS上开启tcpspeed加速。</li><li>编写Python脚本，简化tcpspeed的启动步骤。</li></ol><h2><span id="vultr-shadowsocks-tcpspeed-fen-bie-shi-shi-me">Vultr + Shadowsocks + tcpspeed 分别是什么？</span></h2><p>Vultr是一个VPS租用商，提供了8个套餐，如下：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498838075955.png" alt="Alt text"></p><p>Shadowsocks是一个基于Socks5的代理工具，分为服务端和客户端工具。</p><p><a href="http://www.tcpspeed.com/" target="_blank" rel="noopener">tcpspeed</a>是一个加速方案，能使Shadowsocks最大限度地利用带宽，用官方说法，优势如下：</p><ol><li>速度更快,延迟更短，摆脱tcp协议先天局限性，可以最大限度利用带宽，速度为单边加速2-30倍。</li><li>稳定性更好，抗干扰能力更强，在高丢包,延迟环境下，单边加速下降到几百KB每秒，而TCPSpeed仍然能满速运行。</li><li>响应更迅速，瞬间加载图片，音乐，视频。</li></ol><h2><span id="kai-xiao">开销</span></h2><p>目前本人使用该组合方案近2年的时间，体验下来速度非常快，花费如下：</p><ol><li>VPS选用的Vultr家的，<strong>5美金/月</strong>。</li><li>tcpspeed是一个加速工具，作者常年打折促销，<strong>159元（一次性消费）</strong>购买1个激活码。1个激活码用于1台服务器，不限客户端数量，更换ip，重装系统，更换服务器只需用原激活码重新激活即可继续使用，可以多次使用部署。</li></ol><p>选择VPS的目的还有一个，可以在上面搭建各种好玩的项目，码农闲不住，就喜欢折腾Hello world~</p><h2><span id="vultr-jia-de-vps">Vultr家的VPS</span></h2><h3><span id="zhu-ce-vultr-zhang-hao">注册Vultr账号</span></h3><p>点击进入<a href="http://www.vultr.com/?ref=6859961" target="_blank" rel="noopener">无敌好用便宜量足的Vultr</a>，在Email Address和Password中分别填入邮箱和密码，然后点Create Account创建账号，如下图所示：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498839232705.png" alt="Alt text"></p><p>然后去邮箱中确认校验地址，如图所示：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498839369178.png" alt="Alt text"></p><p>注册好账号后，进入到Servers界面，然后创建一个服务节点：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498839935196.png" alt="Alt text"></p><p>选择日本节点：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840003589.png" alt="Alt text"></p><p>选择CentOS系统：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840022428.png" alt="Alt text"></p><p>选择$5/月的套餐：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840051424.png" alt="Alt text"></p><p>其他的都不用勾选，点击Deploy Now，租用VPS的步骤就搞定了，将会在Server中看到一个服务节点：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840174534.png" alt="Alt text"></p><p>点击进去，查看IP地址和密码：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498908581261.png" alt="Alt text"></p><p>假设你的查看到的IP地址是45.63.12.11使用终端工具远程登录服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh root@45.63.12.11</span></span><br><span class="line">root@45.63.12.11<span class="string">'s password:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入你查看到的Vultr密码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@vultr ~]#</span></span><br></pre></td></tr></table></figure></p><p>当你看到[root@vultr ~]#时，说明已经登录成功。</p><p>接下来可以使用命令安装Shadowsocks：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install python-setuptools &amp;&amp; easy_install pip</span></span><br><span class="line"><span class="comment"># pip install shadowsocks</span></span><br></pre></td></tr></table></figure></p><p>安装成功后，就可以配置shadowsocks的相关配置了，主要为Shadowsocks密码，假设设置为12345678（<strong>自己随意改</strong>），如下图所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi /etc/shadowsocks.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>:8989,</span><br><span class="line">    <span class="string">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:1080,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"12345678"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:300,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="string">"fast_open"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置完后，服务端的Shadowsocks就算是搭建并部署好了，接下来在macOS上安装Shadowsocks客户端。</p><h2><span id="macos-shang-an-zhuang-shadowsocks-ke-hu-duan">macOS上安装Shadowsocks客户端</span></h2><p>下载<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">Shadowsocks客户端</a>，打开服务器设定：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910064168.png" alt="Alt text"></p><p>前面假设过你租用的VPS日本节点IP为45.63.12.11，这个以你实际租用IP地址为准，密码为Vultr上Shadowsocks配置的12345678，新增如下配置：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499007746198.png" alt="Alt text"></p><p>然后点击mac导航栏上的Shadowsocks，选中新增的配置：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499007946797.png" alt="Alt text"></p><p>这些都配置完后，就可以打开浏览器试试油管是否可以打开了：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499008111451.png" alt="Alt text"></p><p>可爱的油管出现啦~<br>但现在的带宽利用率还未发掘到最大，接下来使用tcpspeed将带宽利用最大化。</p><h2><span id="tcpspeed-gou-mai-vultr-fu-wu-duan-bu-shu">tcpspeed购买 + Vultr服务端部署</span></h2><p><a href="http://tcpspeed.com/" target="_blank" rel="noopener">tcpspeed注册和购买，自己去完成吧，很简单~</a></p><p>假设已购买好，会看到如下所示的页面：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499009961669.png" alt="Alt text"></p><p>继续在vultr远程终端上安装tcpspeed工具：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm -f install_tcpspeed.sh ; wget http://www.tcpspeed.com/tcpspeed/install_tcpspeed.sh ; chmod +x install_tcpspeed.sh ; ./install_tcpspeed.sh 2&gt;&amp;1 | tee install.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sh /xs/dactivate.sh 激活码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sh /xs/start.sh</span></span><br></pre></td></tr></table></figure></p><p>再给tcpspeed工具添加一个每晚3点自动重启的定时器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crontab -e</span></span><br><span class="line">0 3 * * * sh /xs/restart.sh</span><br></pre></td></tr></table></figure></p><h2><span id="hui-dao-macos-she-zhi-tcpspeed-ke-hu-duan">回到macOS设置tcpspeed客户端</span></h2><p>添加配置如下：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499002937262.png" alt="Alt text"></p><p>其中密码为之前设置的12345678。</p><p>然后选中它：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499008861444.png" alt="Alt text"></p><p>下载<a href="http://www.tcpspeed.com/tcpspeed/tcpspeed_client3.2.zip" target="_blank" rel="noopener">tcpspeed客户端</a>，将其放置在Applications中：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910319354.png" alt="Alt text"></p><p>创建tcpspeed文件，将以下代码黏贴进去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cd</span>:</span></span><br><span class="line">    <span class="string">"""Context manager for changing the current working directory"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, newPath)</span>:</span></span><br><span class="line">        self.newPath = os.path.expanduser(newPath)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.savedPath = os.getcwd()</span><br><span class="line">        os.chdir(self.newPath)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        os.chdir(self.savedPath)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> cd(<span class="string">"/Applications/tcpspeed_client"</span>):</span><br><span class="line">    os.system(<span class="string">"sudo java -jar tcpspeed_client.jar"</span>)</span><br></pre></td></tr></table></figure></p><p>将tcpspeed文件移至/usr/local/bin中，将该文件改为可执行文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 755 tcpspeed</span></span><br></pre></td></tr></table></figure></p><p>在终端中输入命令运行tcpspeed:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tcpspeed</span></span><br><span class="line"></span><br><span class="line">填写密码</span><br></pre></td></tr></table></figure></p><p>注意：运行tcpspeed需要sudo，所以要填写密码。<br>如果你不怕安全问题，可以在Python脚本中填入系统登录密码，这样就不用每次运行tcpspeed时输入密码了。<br>可以直接把最后一句话改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">"echo 'macOS系统登录密码' | sudo -S java -jar tcpspeed_client.jar"</span>)</span><br></pre></td></tr></table></figure></p><p>设置tcpspeed：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910991989.png" alt="Alt text"><br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910977838.png" alt="Alt text"></p><p>接下来就可以打开油管看视频啦，1080P 毫无压力，秒开高清视频：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499003403532.png" alt="Alt text"></p><p>开心的造起来吧，tumblr上资源多，啊哈哈，譬如用强大的Google搜索：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499008746597.png" alt="Alt text"></p><p>DONE~!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jian-jie&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#zhi-shi-dian&quot;&gt;知识点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vultr-shadow
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-初识ARKit</title>
    <link href="http://fanwt.com/2017/06/29/iOS-%E5%88%9D%E8%AF%86ARKit/"/>
    <id>http://fanwt.com/2017/06/29/iOS-初识ARKit/</id>
    <published>2017-06-29T02:29:53.000Z</published>
    <updated>2017-06-30T02:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#chu-shi-arkit">初识ARKit</a><ul><li><a href="#jia-gou-tu">架构图</a></li><li><a href="#chang-jing-shi-bie">场景识别</a><ul><li><a href="#ping-mian-jian-ce-plane-detection">平面检测（Plane detection）</a></li><li><a href="#peng-zhuang-ce-shi-hit-testing">碰撞测试（Hit-testing）</a></li><li><a href="#gao-guang-gu-suan-light-estimation">高光估算（Light Estimation）</a></li></ul></li><li><a href="#demo">Demo</a><ul><li><a href="#guan-fang-3d-fei-ji-mo-xing-ar-ti-yan">官方3D飞机模型AR体验</a></li></ul></li><li><a href="#zong-jie">总结</a></li></ul></li></ul><!-- tocstop --><p></div></p><h1><span id="chu-shi-arkit">初识ARKit</span></h1><p>Apple在2017WWDC发布会上带来了全新的iOS11，其中最令人瞩目的是引入了ARKit，这是一个新框架，可以让开发者轻松创建无与伦比的iPhone和iPad增强实现体验。通过将虚拟场景与周围的环境融合，ARKit将应用程序超越屏幕，让它们以全新的方式与现实世界进行交互。</p><h2><span id="jia-gou-tu">架构图</span></h2><p>用一张图来展示ARKit框架在应用架构中所处在的位置和功能说明：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-1" alt="ARKit框架在应用架构中所处的位置"></p><p>从上图可知，Apple提供的AR平台底层主要分为2部分：数据分析处理和渲染。<br>ARKit负责数据分析处理，生成AR体验必要的支撑数据，渲染部分Apple提供了3个框架来支持，它们分为两部分：<br>标准渲染视图：SceneKit和SpriteKit，前者提供3D渲染支持，后者提供2D渲染支持。<br>自定义渲染视图：如果觉得Apple提供的标准渲染视图不满足自己的需求，Apple提供了Metal自定义渲染视图框架，来支持自定义渲染视图。</p><p>再来看看ARKit的架构图：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-2" alt="ARKit框架图"></p><p>从上图可知，ARKit框架底层主要功能为追踪，分为2块：摄像头画面实时捕捉视频帧；设备感应硬件检测到的动作数据。<br>ARKit将这2者的数据结合起来分析，生成最终结果，再配合渲染库将2D和3D元素内容实时的显示到用户设备实时的摄像画面中，能使用户体验到AR的错觉乐趣，这些2D或3D元素内容从画面中看上去就像是真实世界中的一部分。</p><p>架构图看完后，再看看ARKit数据处理的主要流程图：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-3" alt="ARKit数据处理流程图"></p><p>从上图流程图中可知，ARKit的核心是ARSession，它管理着AVCaptureSession和CMMotionManager。<br>AVCaptureSession是AVFoundation的核心类，主要用于捕捉视频和音频，协调视频和音频的输入、输出流。<br>CMMotionManager是用于对设备运动识别的，它有2种采样方式：</p><p>PUSH：实时采集所需数据，采样频率高。<br>PULL：在有需要的时候，才去采集数据。<br>要运行一个Session，必须要传入一个ARSessionConfiguration配置，运行中的Session会连续地从AVCaptureSession中捕获实时的摄像画面，再结合CMMotionManager提供的运动数据，最终预测出设备的实际位置。</p><h2><span id="chang-jing-shi-bie">场景识别</span></h2><p>Apple在WWDC大会上展示了ARKit强大的场景识别能力，视频中有两个让人印象特别深刻的地方：<br>1.演讲者使用一个iPhone手机演示将一个逼真的AR战地场景展示在现场桌面上，其中一个小人为了躲避飞机扔下的炮弹，从桌上跳了下去，刚开始以为这仅仅是WWDC现场演示时Demo故意给人错觉的一种演讲效果，但后来回看了下官方文档，确实有提及ARKit是可以捕捉到多个平面的，以及在后来的演示中有看到DEBUG工具展示多个平面网格。<br>2.另一个<a href="https://developer.apple.com/videos/play/wwdc2017/609/" target="_blank" rel="noopener">SpriteKit大会讲解视频</a>(PS:在视频24分)时，视频中游戏演示的小人跳到了桌面上的平层，能够在真实世界的平层上来回走动，是不是很震惊！！！</p><p>从官方的PPT上看到ARKit在场景识别中有3项重要的技术，分别是：</p><ul><li>平面检测（Plane detection）</li><li>碰撞测试（Hit-testing）</li><li>亮度估量（Light estimation）</li></ul><h3><span id="ping-mian-jian-ce-plane-detection">平面检测（Plane detection）</span></h3><p>PPT中概括了4点：</p><ol><li>能检测到相对于重力的水平面，即它能检测的出平面的高低落差层次。</li><li>可以运行多个帧，如果没理解错的话，应该就是可以同时分析检测出多个平面。</li><li>可以对齐置平面的表面上，即当你放置3D精灵视图时，能自动的将3D精灵视图平放到对应的平面上，使它看上去就是像现实中物体放在平面上一样。</li><li>进行平面合并。</li></ol><p>上述可能不是很好理解，用一张图来概括：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-4" alt="ARKit数据处理流程图"></p><p>开启平面检测很方便，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable plane detection on a session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new world tracking configuration</span></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingSessionConfiguration</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable plane detection</span></span><br><span class="line">configuration.planeDetection = .horizontal</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change configuration on currently running session</span></span><br><span class="line">mySession.run(configuration)</span><br></pre></td></tr></table></figure></p><p>ARWorldTrackingSessionConfiguration类是ARSessionConfiguration类的子类。<br>翻看官方文档可知：<br>ARSessionConfiguration类提供3个自由度（DOF）追踪设备的运动：具体来说，三个旋转轴（滚动，俯视和偏航），它支持所有iOS设备上使用ARKit。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-12" alt="ARSessionConfiguration 3DOF"></p><p>ARWorldTrackingSessionConfiguration类是AR体验增强类，对iOS设备要求比较高，需要CPU不低于A9，也就是目前市面上最低iPhone 6s，它提供6个自由度（DOF）追踪设备的运动，比其父类多了3个自由度：三个坐标系（在x、y、z轴上运动）。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-13" alt="ARWorldTrackingSessionConfiguration 6DOF"></p><h3><span id="peng-zhuang-ce-shi-hit-testing">碰撞测试（Hit-testing）</span></h3><p>PPT中概括了4点：</p><ol><li>使用真实世界的相交射线。</li><li>使用场景信息。</li><li>结果按照远近距离排序。</li><li>有4种碰撞测试类型来帮助判断碰撞测试结果。</li></ol><p>Hit-testing会去检测分析出相机图像中的水平面，然后生成其位置和大小的数据。可以把它想象为，摄像头发射一个射线出去，射线碰撞检测到一个点，那么收集到足够多的点就能分析出平面，最终生成返回数据。</p><p>如图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-9" alt="Hit-testing"></p><p>基于Hit-testing建立一个锚点，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding an ARAnchor based on hit-test</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="type">CGPoint</span>(x:<span class="number">0.5</span>, y:<span class="number">0.5</span>) <span class="comment">// Image center</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform hit-test on frame</span></span><br><span class="line"><span class="keyword">let</span> results = frame.hitTest(point, types:[.existingPlane, .estimatedHorizontalPlane])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the first result</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> closestResult = results.first &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an Anchor for it</span></span><br><span class="line"><span class="keyword">let</span> anchor = <span class="type">ARAnchor</span>(transform: closestResult.worldTansform)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add it to the session</span></span><br><span class="line">session.add(anchor: anchor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ARSKView、ARSCNView、ARFrame类中提供了hitTest方法，用于碰撞测试检测分析出平面，方法返回一组ARHitTestResult对象，该方法传入2个参数，第一个参数为CGPoint点，第二个参数为检测碰撞结果的类型，有4种：</p><ol><li>ARHitTestResult.ResultType.featurePoint，根据距离最近的特征点检测出来的连续表面。</li><li>ARHitTestResult.ResultType.estimatedHorizontalPlane，非精准方式计算出来与重力垂直的平面。</li><li>ARHitTestResult.ResultType.existingPlane，已经检测出来的平面，检测时忽略平面本身大小，把它看做一个无穷大的平面。</li><li>ARHitTestResult.ResultType.existingPlaneUsingExtent，已经检测出来的平面，检测时考虑平面本身的大小。<br>这4种类型可以用|来同时传入。</li></ol><h3><span id="gao-guang-gu-suan-light-estimation">高光估算（Light Estimation）</span></h3><p>在AR增强视觉体验中，如果虚拟内容的高光与环境不符，那还是挺容易看得出这就是一个虚拟物体的。<br>ARKit提供来一个检测视频图像环境光照强度的功能，主要是为了让3D模型的光照与环境的光照强度保持一致。<br>ARKit默认开启了这项检测，且流明度默认值为1000。</p><p>用图来展示ARKit强大的魅力：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-7" alt="Light Estimation 1"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-8" alt="Light Estimation 2"></p><h2><span id="demo">Demo</span></h2><h3><span id="guan-fang-3d-fei-ji-mo-xing-ar-ti-yan">官方3D飞机模型AR体验</span></h3><p>在Xcode9 beta1中，官方在模板工程中提供了2个示例：SceneKit和SpriteKit，前者3D，后者2D。<br>在Xcode9 beta2中，官方在模板工程中又新增了1个Metal的示例，可以使用Metal技术来自定义渲染视图，该种实现方式比SceneKit和SpriteKit这两种方式复杂的多，<a href="https://developer.apple.com/documentation/arkit/displaying_an_ar_experience_with_metal" target="_blank" rel="noopener">具体细节请参阅官方文档</a>。</p><p>你可以新建一个工程，选择AR模版，在Content Technology中选择使用SceneKit或SpriteKit或Metal，这里选用SceneKit。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-10" alt="Demo 1"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-11" alt="Demo 1"></p><p>模板工程很简单，如下图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-14" alt="Demo 1"></p><p>art.scnassets为AR素材资源目录，官方提供了一个飞机建模：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-15" alt="Demo 1"></p><p>ViewController.swift中的代码如下（删去了暂时无用的空代理回调方法）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the view's delegate</span></span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">        sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new scene</span></span><br><span class="line">        <span class="keyword">let</span> scene = <span class="type">SCNScene</span>(named: <span class="string">"art.scnassets/ship.scn"</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the scene to the view</span></span><br><span class="line">        sceneView.scene = scene</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a session configuration</span></span><br><span class="line">        <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingSessionConfiguration</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the view's session</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pause the view's session</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码解读：</p><ol><li>渲染模块使用ARSCNView视图，它支持3D模型渲染。</li><li>在viewDidLoad中设置sceneView的代理，以及现实FPS状态，然后加载飞机3D模型，并将其设置为sceneView的scene属性。</li><li>view即将展现时，配置一个ARWorldTrackingSessionConfiguration对象（支持6DOF），将使用该配置来运行Session。</li><li>view即将消失时，暂停Session的运行。</li></ol><p>当你使用A9+设备运行该工程时，会在摄像画面的水平正前方出现一架飞机3D模型，可以像正常拍摄一个物体一样360度查看它，如下图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-16.gif" alt="ARKit-SceneKit-Demo"></p><p>简简单单的几行代码便将一个飞机3D模型实时渲染到了实时的视频画面中，还支持6轴运动，不得不说ARKit将AR门槛降低了非常多，使得开发者很轻松地创建出AR体验APP。</p><p>官方提供了一个<a href="https://developer.apple.com/sample-code/wwdc/2017/PlacingObjects.zip" target="_blank" rel="noopener">较为复杂的ARDemo</a>，可以放置一些家具的，画面很逼真，并提供了DEBUG的工具来帮助开发者理解ARKit相关特性，如图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-17" alt="ARKit-SceneKit-Demo"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-18.gif" alt="ARKit-SceneKit-Demo"></p><h2><span id="zong-jie">总结</span></h2><p>ARKit支持所有的设备，在CPU A9以下的设别，提供基础的3DOF（滚动，俯视和偏航）支持，在CPU A9及以上，提供6DOF（滚动，俯视和偏航，以及三个坐标系（在x、y、z轴上运动））支持。</p><p>ARKit提供了强大的数据分析能力，将实时画面帧与设备运行数据结合，为开发者创建无比惊艳的AR体验APP提供了强大的数据支撑。要开发AR体验APP，需要开发者具备以下知识：</p><ol><li>线性代数-矩阵计算，推荐一个视频：<a href="http://www.bilibili.com/video/av6731067/" target="_blank" rel="noopener">线性代数的本质 - 系列合集</a>。</li><li>熟悉ARKit框架。</li><li>熟悉SceneKit、SpriteKit，这是Apple提供的标准渲染视图，内部处理了绝大部分的渲染处理，能帮助开发者降低渲染AR所具备的知识。</li><li>如果要自定义渲染，可以使用Apple提供的Metal框架，今年会发布Metal2，性能进一步提升。</li></ol><p>可以预测到iOS11正式发布时，将会有众多应用会借势ARKit上首推，特别是游戏类APP，譬如以前大火的植物大战僵尸、水果忍者、宠物精灵、飞行游戏、养成类游戏等等，一般应用中大多数是活动场景，好比：AR抢红包、寻宝、展示等等。</p><p>目前正处于Beta阶段的AR体验还有待改进，真机体验的时候，还是能很明显的感受到虚拟物品会漂移或不自然的抖动，慢慢静待Apple的修正吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#chu-shi-arkit&quot;&gt;初识ARKit&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jia-gou-tu&quot;&gt;架构图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chang
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS - 按纯色行切页</title>
    <link href="http://fanwt.com/2017/03/28/iOS-%E6%8C%89%E7%BA%AF%E8%89%B2%E8%A1%8C%E5%88%87%E5%88%86%E9%A1%B5/"/>
    <id>http://fanwt.com/2017/03/28/iOS-按纯色行切分页/</id>
    <published>2017-03-28T02:00:48.000Z</published>
    <updated>2018-01-24T16:27:01.628Z</updated>
    
    <content type="html"><![CDATA[<p>DTCoreText库是iOS端富文本渲染库，开发阅读类产品时可以使用该库进行富文本渲染，它提供了CSS样式解析和HTML富文本样式的排版，支持图片、视频这类附件内容的混合排版。</p><h2><span id="jian-dan-jie-shao">简单介绍</span></h2><p>它的底层使用的Apple提供的CoreText库，命名几乎和CoreText库保持一致，上手简单快速，步骤十分简单容易：</p><ol><li><p>加载CSS样式。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* cssPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"style"</span> ofType:<span class="string">@"css"</span>];</span><br><span class="line"><span class="built_in">NSString</span>* cssString = [<span class="built_in">NSString</span> stringWithContentsOfFile:cssPath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>] ;</span><br><span class="line">DTCSSStylesheet* css = [[DTCSSStylesheet alloc] initWithStyleBlock:cssString];</span><br><span class="line">[[DTCSSStylesheet defaultStyleSheet] mergeStylesheet:css];</span><br></pre></td></tr></table></figure></li><li><p>加载HTML内容，将它转换为富文本对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *htmlString = <span class="string">@"TODO"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *data = [htmlString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSAttributedString</span>* attributedContent = [[<span class="built_in">NSAttributedString</span> alloc] initWithHTMLData:data</span><br><span class="line">                                                                                 options:<span class="literal">nil</span></span><br><span class="line">                                                                      documentAttributes:<span class="literal">nil</span>];</span><br><span class="line">DTCoreTextLayouter* layouter = [[DTCoreTextLayouter alloc] initWithAttributedString:attributedContent];</span><br></pre></td></tr></table></figure></li><li><p>生成渲染对象。（分页和不分页的区别在于生成渲染对象时指定的分页高度，不分页需要设置为CGFLOAT_HEIGHT_UNKNOWN）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设画布为屏幕大小，不分页，所有内容在一页显示</span></span><br><span class="line"><span class="built_in">NSInteger</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CGRect</span> rect = [[<span class="built_in">UIScreen</span> mainScreen] bounds];</span><br><span class="line">rect.size.height = <span class="built_in">CGFLOAT_HEIGHT_UNKNOWN</span>;</span><br><span class="line">DTCoreTextLayoutFrame *layoutFrame = [dtLayouter layoutFrameWithRect:rect range:<span class="built_in">NSMakeRange</span>(position, <span class="number">0</span>)]; <span class="comment">// 渲染对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设画布为屏幕大小，按照屏幕大小分页</span></span><br><span class="line"><span class="built_in">NSInteger</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CGRect</span> rect = [[<span class="built_in">UIScreen</span> mainScreen] bounds];</span><br><span class="line">DTCoreTextLayoutFrame *layoutFrame = [dtLayouter layoutFrameWithRect:rect range:<span class="built_in">NSMakeRange</span>(position, <span class="number">0</span>)]; <span class="comment">// 渲染对象</span></span><br></pre></td></tr></table></figure></li></ol><p>上面代码中使用了它提供的一个简单易懂的分页API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> Creates a layout frame with a given rectangle and string range. The layouter fills the layout frame with as many lines as fit. You can query [DTCoreTextLayoutFrame visibleStringRange] for the range the fits and create another layout frame that continues the text from there to create multiple pages, for example for an e-book.</span><br><span class="line"> @param frame The rectangle to fill with text</span><br><span class="line"> @param range The string range to fill, pass &#123;0,0&#125; for the entire string (as much as fits)</span><br><span class="line"> */</span><br><span class="line">- (DTCoreTextLayoutFrame *)layoutFrameWithRect:(CGRect)frame range:(NSRange)range;</span><br></pre></td></tr></table></figure></p><p>该API给定一个frame大小，然后告诉它从什么range开始分页，返回切好的富文本渲染对象，该对象包含了该页所有渲染的lines和attachments对象，将DTCoreTextLayoutFrame设置到DTAttributedTextContentView中，即可展示出分页的富文本内容。</p><ol><li><p>将渲染对象画在视图上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DTAttributedTextContentView *attributedTextContentView = [DTAttributedTextContentView new];</span><br><span class="line">attributedTextContentView.frame = [[<span class="built_in">UIScreen</span> mainScreen] bounds];</span><br><span class="line">attributedTextContentView.layoutFrame = layoutFrame;</span><br></pre></td></tr></table></figure></li><li><p>附件的处理<br>如果内容中有附件：图片、视频、占位，需要在代理回调中返回UIView，该view的坐标和大小是在HTML中提前指定好的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)attributedTextContentView:(DTAttributedTextContentView *)attributedTextContentView viewForAttachment:(DTTextAttachment *)attachment frame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">if</span> ([attachment isKindOfClass:[DTIframeTextAttachment <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        DTWebVideoView *videoView = [[DTWebVideoView alloc] initWithFrame:frame];</span><br><span class="line">        videoView.attachment = attachment;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> videoView;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([attachment isKindOfClass:[DTObjectTextAttachment <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// somecolorparameter has a HTML color</span></span><br><span class="line">        <span class="built_in">NSString</span> *colorName = [attachment.attributes objectForKey:<span class="string">@"somecolorparameter"</span>];</span><br><span class="line">        <span class="built_in">UIColor</span> *someColor = DTColorCreateWithHTMLName(colorName);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIView</span> *someView = [[<span class="built_in">UIView</span> alloc] initWithFrame:frame];</span><br><span class="line">        someView.backgroundColor = someColor;</span><br><span class="line">        someView.layer.borderWidth = <span class="number">1</span>;</span><br><span class="line">        someView.layer.borderColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line"></span><br><span class="line">        someView.accessibilityLabel = colorName;</span><br><span class="line">        someView.isAccessibilityElement = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> someView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>仅需5步就可完成富文本的排版渲染，是不是简单且高效？</p><p>为了增加用户粘性，在每个章节末页增加作者头像、昵称、感言和本章精彩评论，营造一个良好的社区环境，引起读者的共鸣。在开发章末非正文的附加页（作家感言、精彩评论、推荐内容等自定页）时，技术预言了不同的几种技术方案：</p><ol><li>正文页和附加页都使用DTCoreText进行排版渲染。该种技术实现方式在技术预言过程中发现，随着页面复杂度的提高，曲线陡升式的提高了附加页的开发成本，大大增加开发人员的学习成本，且DTCoreText支持的CSS样式和HTML标签非常有限，如果遇到设计稿中复杂的排版样式，这种风险无意是颗定时炸弹，最终将会导致项目难以扩展和维护。</li><li><p>正文页使用DTCoreText排版渲染，附加页使用传统的UIView开发方式，该种技术实现方式有2种完全不一样的解耦实现方案：</p><ul><li><p>方案一：附加页自带分页算法，即编写附加页的开发人员在编写UI时，需要提供一个分页算法，将其拼接到正文页末。该方案对开发人员对分页算法技术要求较高，需要计算每行的排版坐标，在分页计算时对每行进行坐标位置计算，最终确定每页填充的渲染内容。</p></li><li><p>方案二：附加页不自带分页算法，由一个公共的切页算法对附加页进行页面切分，需要抽象出分页的规则，定制一套附加页UI开发标准。该方案对开发人员要求较低，开发人员无需了解分页排版算法，按照UI开发标准完成组件开发后，交由阅读开发人员编写的统一切页算法器完成附加页接入正文页末。</p></li></ul><p>方案二更优不是吗？任何开发人员都能写阅读章末页的附加UI，从此再也不害怕产品大大对章末附加页有天马行空的想法了，是不是很赞？</p></li></ol><h2><span id="que-ding-fang-an-qian-de-yi-wen">确定方案前的疑问</span></h2><ol><li>真的有一种通用的算法来切分任意的附加页吗？</li><li>它是否真的不需要附加页开发参与到分页算法的开发中？</li><li>它是否能满足产品天马行空的想法呢?</li><li>通常一个通用的算法多多少少会在性能上有一定的损耗，这个损耗在用户侧是否能忽略不计呢？</li><li>它能否成为SDK，提供给其他项目使用？</li></ol><h2><span id="ji-zhu-fang-an-que-ding-li-yong-chun-se-xing-jin-xing-fen-ye-pan-duan">技术方案确定 - 利用纯色行进行分页判断</span></h2><p>确定使用技术方案二之后，纵观APP内所有UI页面，能够发现分页算法可以使用纯色行来判断，能否分页要看Y坐标这行的每个像素点是否是一样的色值（RGBA四个都一样，则色值相等），假设这行Y坐标中有不一样的色值，可能是该行有文字、图片、按钮等内容，这时分页的Y坐标要继续换行判断。</p><p>任何过早的优化都是浪费时间和精力，所以先假设UI规范不搞特殊化，即任何页面都能</p><p>技术预言使用DTCoreText + 自定义UIView排版，即正文内容使用DTCoreText的HTML格式来进行排版渲染，末页的附加页使用UIView的传统页面开发方式，<br> 了2种不同方向的解耦做法：</p><p>优秀的APP都会增加用户粘性，阅读APP以优秀的内容取胜，</p><p>实际的开发中还会遇到DTCoreText + 自定义UIView排版，产品大大在每章的章末页添加用户黏性页面，例如作家感言、精彩评论、推荐内容等自定页，这里简称这些非正文内容页面为附加页，该附加页样式复杂，如果附加页也使用DTCoreText库中的HTML、CSS样式来渲染，很可能遇到许多不支持的标签，同时会改变客户端开发习惯，无法使用已开发好的公共组件。如果不使用该库，就会遇到另外一个问题，如何把附加页跟随在正文之后进行分页排版？例如：在正文末页添加一个作者头像、名称、作者感言页和本章精彩评论，该附加页需要和正文一样进行分页排版，每章的附加页都是动态内容，即附加页是动态高度。</p><p>方案一：<br>编写附加页代码时，自带算法进行切页。这种方案对开发人员编码能力要求较高，开发页面时需对不同排版进行适配切页规则，每开发一个新页面时，都需要自带切页算法。</p><p>方案二：<br>编写附加页代码时，不带算法进行分页。这种方案需要制定一套附加页开发标准和切页规则，编写附加页的开发人员要按照该套标准进行页面开发，再交由统一的切页算法进行切页。</p><p>附加页标准：</p><ol><li>按照什么算法进行页面切分。</li><li>切页后，当中页面的顶部和底部间距。</li><li>尾页的处理。</li></ol><p>开发过程中又需要解耦模块，不希望这个新增的页面影响到阅读渲染本身，我这里有一种尝试思路，如有问题希望轻拍。</p><p>PS：目前还未运用到实际项目中，只是一个解耦的想法而已💡</p><h2><span id="jie-jue-si-lu">解决思路</span></h2><ol><li>如何解决在已渲染好的阅读页中动态加入自定义页，不影响阅读页排版功能，不侵入阅读代码？<br>答：假设自定页面只有一页，且高度就是该阅读页正文显示完剩余的区域，那么直接将自定义页面以addSubView的形式加入到该阅读页。</li><li>当自定义页超过一屏时，如何尽可能小影响或不影响阅读翻页逻辑？<br>答：前提：目前我们的阅读框架中每页是否有下一页是一个动态询问过程，翻页手势会询问容器中的当前页是否有前、后一页。修改点：询问逐层传递的思想，修改后，阅读页中有自定义子页时，应优先询问子页是否有下一页，如果有，下一页显示自定义子页，如果没有，再看阅读页自身是否有下一页。</li></ol><h2><span id="he-xin-ru-he-qie-ye">核心：如何切页</span></h2><p>自定义页面转为像素data，注意不要用高清，节省内存，给一个起始锚点，逐行扫描，当遇到色值不一样时，换行。<br>代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    eFindPureSeparateLinePointDirection_down = <span class="number">0</span>,</span><br><span class="line">    eFindPureSeparateLinePointDirection_up</span><br><span class="line">&#125;eFindPureSeparateLinePointDirection;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">WtExt</span>)</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)wt_findPureSeparateLinePointWithAnchor:(<span class="built_in">CGPoint</span>)point direction:(eFindPureSeparateLinePointDirection)direction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">WtExt</span>)</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)wt_findPureSeparateLinePointWithAnchor:(<span class="built_in">CGPoint</span>)point direction:(eFindPureSeparateLinePointDirection)direction &#123;</span><br><span class="line">    <span class="keyword">int</span> preR = <span class="number">-1</span>, preG = <span class="number">-1</span>, preB = <span class="number">-1</span>, preA = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    size_t pixelsWidth = <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.frame);</span><br><span class="line">    size_t pixelsHeight = <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.frame);</span><br><span class="line">    <span class="keyword">int</span> x = point.x;</span><br><span class="line">    <span class="keyword">int</span> y = point.y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> scale = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.frame.size.width*scale, <span class="keyword">self</span>.frame.size.height*scale) ;</span><br><span class="line">    <span class="keyword">int</span> bitPerRow = size.width * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> bitCount = bitPerRow * size.height;</span><br><span class="line">    <span class="built_in">UInt8</span> *bitdata = malloc(bitCount);</span><br><span class="line">    <span class="keyword">if</span> (bitdata == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> deviceRGB = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="keyword">if</span> (deviceRGB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRef</span> contex = <span class="built_in">CGBitmapContextCreate</span>(bitdata, size.width, size.height, <span class="number">8</span>, bitPerRow, deviceRGB, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    <span class="keyword">if</span> (contex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(deviceRGB);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(deviceRGB);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(contex, <span class="number">0</span>, size.height);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(contex, scale, -scale);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.layer renderInContext:contex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = (direction==eFindPureSeparateLinePointDirection_down)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &gt;= pixelsHeight || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">-1</span>;</span><br><span class="line">            y = INT_MAX;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= pixelsWidth) &#123;</span><br><span class="line">            x = point.x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">4</span>*((pixelsWidth*round(y))+round(x));</span><br><span class="line">        <span class="keyword">if</span> (preR == <span class="number">-1</span>) &#123;</span><br><span class="line">            preR = bitdata[offset];</span><br><span class="line">            preG = bitdata[offset+<span class="number">1</span>];</span><br><span class="line">            preB = bitdata[offset+<span class="number">2</span>];</span><br><span class="line">            preA = bitdata[offset+<span class="number">3</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (preR != bitdata[offset] ||</span><br><span class="line">                preG != bitdata[offset+<span class="number">1</span>] ||</span><br><span class="line">                preB != bitdata[offset+<span class="number">2</span>] ||</span><br><span class="line">                preA != bitdata[offset+<span class="number">3</span>]) &#123;</span><br><span class="line"></span><br><span class="line">                x = point.x;</span><br><span class="line">                y += i;</span><br><span class="line">                preR = <span class="number">-1</span>, preG = <span class="number">-1</span>, preB = <span class="number">-1</span>, preA = <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contex);</span><br><span class="line">    free(bitdata);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DTCoreText库是iOS端富文本渲染库，开发阅读类产品时可以使用该库进行富文本渲染，它提供了CSS样式解析和HTML富文本样式的排版，支持图片、视频这类附件内容的混合排版。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;jian-dan-jie-shao&quot;&gt;简单介绍&lt;/span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS - 路由解耦</title>
    <link href="http://fanwt.com/2017/03/25/iOS-JSSDK/"/>
    <id>http://fanwt.com/2017/03/25/iOS-JSSDK/</id>
    <published>2017-03-25T06:09:42.000Z</published>
    <updated>2017-03-25T06:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#lu-you-jie-ou-shi-sha">路由解耦是啥？</a></li><li><a href="#lu-you-jie-ou-neng-jie-jue-shi-me">路由解耦能解决什么？</a></li><li><a href="#ji-zhu-xu-qiu-bei-jing">技术需求背景</a></li><li><a href="#zheng-li-ji-zhu-shi-xian-si-lu">整理技术实现思路</a></li><li><a href="#yi-hybrid-jssdk">一、Hybrid(JSSDK)</a><ul><li><a href="#hybrid-jssdk-de-shi-yong-chang-jing-ji-url-ju-li">Hybrid(JSSDK)的使用场景及URL举例</a></li></ul></li><li><a href="#er-openurl">二、OpenURL</a><ul><li><a href="#openurl-yu-dao-de-keng">OpenURL遇到的坑</a></li><li><a href="#openurl-de-shi-yong-chang-jing-ji-url-ju-li">OpenURL的使用场景及URL举例</a></li></ul></li><li><a href="#san-universal-links">三、Universal Links</a><ul><li><a href="#universal-links-de-shi-yong-chang-jing-ji-url-ju-li">Universal Links的使用场景及URL举例</a></li></ul></li><li><a href="#shi-xian-yao-dian">实现要点</a><ul><li><a href="#jie-xi-url-de-ru-kou">解析URL的入口</a></li><li><a href="#jie-xi-hou-de-zi-duan-zuo-lu-you-zhuan-fa">解析后的字段作路由转发</a></li></ul></li><li><a href="#wei-wan-dai-xu">未完待续</a></li></ul><!-- tocstop --></div><h2><span id="lu-you-jie-ou-shi-sha">路由解耦是啥？</span></h2><p>路由解耦，故名思意就是使用URL，根据请求地址进行解析，映射到相关代码的逻辑操作，诸如：页面跳转、UI弹层展示、事件分发、IO存储等等，对于调用方来说，使用统一标准化格式的URL协议即可。<br>在iOS端的开发中，使用URL交互的地方无外乎：应用内Web、应用外Web、应用模块间解耦单向通信（双向通信使用模块暴露接口会更佳合理和优雅），本文将从Hybrid(JSSDK)、OpenURL(iOS9-)、Universal Links(iOS9+)三方面阐述路由解耦设计的一些经验和思考。</p><h2><span id="lu-you-jie-ou-neng-jie-jue-shi-me">路由解耦能解决什么？</span></h2><ol><li>应用内Web，使用封装的Hybrid(JSSDK)进行双向通信。</li><li>应用外Web，会受到制约：有的APP比较强势，会拦截URL，不允许跳转到外部应用，例如：微信。iOS8目前仍无解(用户占比少)，但iOS9+(用户占比极高)的设备可以使用Universal Links来解决该问题。</li><li>应用模块间解耦单向通信，相当于给模块暴露的单向通信接口起一个URL的别名，好处是方便业务部门的人来使用，例如：活动配置，下发URL可以跳转到相应的页面。</li></ol><h2><span id="ji-zhu-xu-qiu-bei-jing">技术需求背景</span></h2><ol><li>在早期的iOS开发中，经常需要会遇到调用或跳转外部其他App，诸如：在关于联系我们页面中的电话点击事件触发后直接拨打电话、点击email时弹出发送邮件页（预设好接受人email、主题、内容等）、跳转到Apple的设置页、跳转到Sina微博分享等等，Apple在iOS2.0时提供了OpenURL解决方案来支持上述的需求场景。</li><li>项目中有很多活动相关的Web页，在Web页面中常常需要获取客户端的信息、调用客户端的原生功能，诸如：获取客户端版本号、打开客户端的原生页面、修改导航栏色值、调用客户端的本地逻辑操作等。</li><li>在微信这种强势APP中，OpenURL被它拦截，导致无法跳转自己的APP 的相关功能页。</li><li>由于OpenURL的过程没有任何安全性校验，导致APP内支持的OpenURL可能会被任何的App随时呼起，以及滥用其中的功能。Apple考虑到OpenURL安全性不足，于是在iOS9中推出了Universal Links(通用链接)和ATS 隐私控制，不在AASA、ATS白名单的域名统统被拒绝。我们工程最低版本支持iOS8+，Web页在iOS8的设备上能通过OpenURL唤起APP，但iOS9+后，由于未配置Universal Links，导致OpenURL失效，最终无法唤起APP。</li></ol><h2><span id="zheng-li-ji-zhu-shi-xian-si-lu">整理技术实现思路</span></h2><p>Hybrid(JSSDK)、OpenURL、Universal Links三者都是使用URL统一资源定位符来与客户端通信，这三者的通性，利用这一点，只要URL统一规则，客户端就可以无差别的解析处理了。<br>格式定义如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://module:port/method?&#123;query:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p><ol><li>关于scheme，Hybrid(JSSDK)、OpenURL、Universal Links可以使用一致的scheme，一般而言，scheme统一使用项目的scheme即可。Hybrid(JSSDK)使用了scheme为jsbridge来区分这是JSSDK的API。</li><li>port，解析后，只有Hybrid(JSSDK)会使用该参数进行OC与JS通信，实现原理很简单，JS提供一个回调方法，port参数用于告知是哪一个事件回调了，就像设置了一个delegate。OpenURL、Universal Links只能URL-&gt;客户端的单向通信，无法回传数据给调用方，即无法使用、也不需要port参数。</li><li>module，模块，映射到客户端的哪个模块。</li><li>method，方法，映射到客户端的哪个模块的哪个方法。</li><li>query，参数，映射到客户端的哪个模块的哪个方法中的参数。</li></ol><p>不同的iOS版本、应用内、应用外，使用的安全处理机制不一样，解决方案如下：</p><ol><li>iOS8设备，Hybrid(JSSDK) 有自己单独的域名白名单，可以监管到安全问题；OpenURL可以随意调用，无法监管到安全问题。</li><li>iOS9+设备，Hybrid(JSSDK) 有自己单独的域名白名单，可以监管到安全问题；应用内HTTP、Web由ATS监管安全问题；Universal Links使用配置的apple-app-site-association来监管安全问题。<blockquote><p><strong>注意：如果开启了ATS功能，iOS9和iOS10还是有些区别的，iOS9中的ATS没有区分本地请求和Web请求，iOS10中考虑到Web无法全部使用ATS的场景，所以如果在项目中开启了ATS并设置了NSExceptionDomains白名单以及开启了NSAllowsArbitraryLoadsInWebContent字段为true，那在iOS9应用内Web会验证白名单，而iOS10应用内Web不会验证白名单，直接使用NSAllowsArbitraryLoadsInWebContent允许全部的web关闭ATS验证。当前iOS端主流最低支持版本为iOS8+，这就需要和客户端合作的Web前端同学注意资源域名要在白名单中才能兼容iOS9的设备Web正常访问资源。</strong></p></blockquote></li></ol><h2><span id="yi-hybrid-jssdk">一、Hybrid(JSSDK)</span></h2><p>关于JSSDK，核心技术有以下几点：</p><ol><li><p>URL的协议定义，上述讲了，为了避免上翻回去查找，这里再贴一次，格式为：</p><blockquote><p>scheme://module:port/method?{query:{}}</p></blockquote></li><li><p>使用OC的动态性、以及使用block回调，动态查找类、方法，动态调用方法，动态传入参数，动态性+block的组合很完美。</p></li><li>利用port字段，在OC回调JS方法时传入，作为delegate使用，这样就支持了OC与JS的双向通信能力。<br>实际编码过程中，JSSDK的核心代码量不超过100行，是不是特别简单容易理解。</li></ol><h3><span id="hybrid-jssdk-de-shi-yong-chang-jing-ji-url-ju-li">Hybrid(JSSDK)的使用场景及URL举例</span></h3><p>举例双向通信和单向通信，栗子来了：<br>使用场景如下：</p><ol><li><p>Web页调用JS获取客户端的信息，通过port端口号回调JS方法，好比：获取客户端的VersionCode，如下代码所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向通信</span></span><br><span class="line">jsbridge:<span class="comment">//device:1/versionCode</span></span><br></pre></td></tr></table></figure></li><li><p>Web页调用JS设置导航栏右侧按钮，点击按钮后，通过port端口号回调JS方法，好比：设置Web页导航栏右侧按钮为分享，如下代码所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向通信</span></span><br><span class="line">jsbridge:<span class="comment">//ui:2/setHeaderRight?&#123;"query":&#123;"icon":"share"&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>应用内Web页的JS -&gt; OC 单向通信，好比：Web页中点击封面跳转客户端原生书籍详情页：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向通信</span></span><br><span class="line">jsbridge:<span class="comment">//app/showBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="er-openurl">二、OpenURL</span></h2><p>OpenURL设计的目的就是解耦模块，我们来看看它能做什么：</p><ol><li>Apple就提供了若干的功能，诸如：打电话、发邮件、打开AppStore等。</li><li>常见的第三方登录模块也用的OpenURL来进行APP间跳转式的双向通信。</li><li>APNS推送中可以添加字段URL，用户点击推送后，可以执行相应逻辑，这里能很清楚地看得到模块间的解耦。</li><li>桌面APP使用3D Touch时，可以用OpenURL的思路解决模块解耦问题，在设置3D Touch项时，使用OpenURL作为item的描述，这样3D Touch回调事件里只需写一句话：执行OpenURL。</li></ol><h3><span id="openurl-yu-dao-de-keng">OpenURL遇到的坑</span></h3><p>实际使用过程中，我发现Apple的OpenURL效率并不高，在某些场景下速度慢的惊人，譬如上述它能做什么中的第4点，如果在3D Touch回调中直接使用Apple的OpenURL方法，真机上看到的现象是进入APP奇慢无比，像是卡住了一样。3D Touch回调事件代码如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *urlString = shortcutItem.type;</span><br><span class="line">    <span class="keyword">if</span> (urlString.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:[urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法也很简单：<br>其实想想就知道OpenURL是用于APP外部调用的，在我们APP应用内直接走解析URL和动态执行方法就好了。改进后的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *urlString = shortcutItem.type;</span><br><span class="line">    <span class="keyword">if</span> (urlString.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> qd_handleActionUrl:[<span class="built_in">NSURL</span> URLWithString:[urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="openurl-de-shi-yong-chang-jing-ji-url-ju-li">OpenURL的使用场景及URL举例</span></h3><p>使用场景如下：</p><ol><li><p>应用内部调用URL路由作模块解耦，好比：书籍详情页调用加书架功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//app/addToBookshelf?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>APNS推送点击后可以响应客户端本地事件，好比：用户收到了一条热门书籍推送，点击推送后跳转客户端原生书籍详情页：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//app/showBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="san-universal-links">三、Universal Links</span></h2><p>这里讲到它的目的，是以下2点：</p><ol><li>在iOS9+时，Apple提出了ATS的要求，以前的OpenURL在Web前端可以随意被其他APP滥用，没有任何的安全机制保护，于是推出了Universal Links来增加OpenURL在Web前端的安全合法校验，只有域名验证通过的链接，才能使用OpenURL打开APP。</li><li>微信中拦截了URL，不让跳转到外部应用中。但Universal Links是系统级别的，可以绕过微信的拦截限制。</li></ol><p>它和Hybrid(JSSDK)、OpenURL的URL格式有所区别，它的格式如下：<br>PS: 由于Universal Links只作单向通信，所以我们忽略port参数(port参数的目的就是作为双向通信delegate)。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:<span class="comment">//host/route/module/method?&#123;query:&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><p>它的区别在于:它多出来了host/route，除了这一点，其他格式和Hybrid(JSSDK)、OpenURL的URL毫无差别，所以当客户端接收到URL时，过滤掉host/route就可以了。</p><h3><span id="universal-links-de-shi-yong-chang-jing-ji-url-ju-li">Universal Links的使用场景及URL举例</span></h3><p>使用场景如下：</p><ol><li><p>iOS9+在Web前端的链接，好比：书籍详情页调用加书架功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//qidian.com/reader/app/addToBookshelf?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>微信中点击链接打开客户端原生页面， 好比：微信公众号里分享了一本经典小说，点击后跳转打开客户端原生阅读页：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//qidian.com/reader/app/openBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="shi-xian-yao-dian">实现要点</span></h2><h3><span id="jie-xi-url-de-ru-kou">解析URL的入口</span></h3><p>Hybrid(JSSDK)、OpenURL、Universal Links 3者处理URL入口不一样，具体如下：</p><ol><li><p>Hybrid(JSSDK)在UIWebView的delegate回调中拦截URL进行特殊处理，如果Hybrid(JSSDK)拦截成功，则直接返回NO，打断UIWebView自身的处理逻辑；否则返回YES，继续UIWebView的处理逻辑，方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)webView:shouldStartLoadWithRequest:navigationType:</span><br></pre></td></tr></table></figure></li><li><p>OpenURL，在AppDelegate的回调中处理解析URL，iOS8与iOS9的有所区别，如下所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS9代理回调方法</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)application:openURL:options:</span><br><span class="line"></span><br><span class="line"><span class="comment">//iOS8代理回调方法</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)application:openURL:sourceApplication:annotation:</span><br></pre></td></tr></table></figure></li><li><p>Universal Links，在AppDelegate的回调中处理解析URL，方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要注意一点的是，通用链接过来的URL，会带有host/route，在代理方法中需要过滤掉host/route，将格式统一为scheme://module/method?&#123;query:&#123;&#125;&#125;</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)application:continueUserActivity:restorationHandler:</span><br></pre></td></tr></table></figure></li><li><p>暴露了一个C函数，方便跨模块调用，主要用于解耦目的。目前只支持单向通信（考虑到双向通信会增加复杂度，使用模块对外暴露接口更优雅，所以暂不考虑双向通信）。举例，调用方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QDRouteBridge(<span class="string">@"QDReader://app/addToBookshelf?&#123;\"query\":&#123;\"bookId\": 1004976324&#125;&#125;"</span>)</span><br></pre></td></tr></table></figure></li></ol><h3><span id="jie-xi-hou-de-zi-duan-zuo-lu-you-zhuan-fa">解析后的字段作路由转发</span></h3><p>当成功解析了scheme、port、module、method、query部分后，iOS客户端会通过module映射到一个类名，method映射到其中的一个具体方法，query、port这2个作为传入参数，然后执行该方法。<br>总结关键执行步骤：</p><ol><li>映射到具体的类。</li><li>拼接方法名。</li><li>利用OC语言的动态性，动态调用方法。<br>关键的代码部分：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)qd_handleJsRequest:(<span class="built_in">NSURL</span> *)request module:(<span class="built_in">NSString</span> *)module method:(<span class="built_in">NSString</span> *)method port:(<span class="built_in">NSNumber</span> *)port query:(<span class="built_in">NSDictionary</span> *)query fromEnv:(<span class="built_in">NSDictionary</span> *)env &#123;</span><br><span class="line">    <span class="keyword">if</span> (!request ||</span><br><span class="line">        !module ||</span><br><span class="line">        !method) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"qd_handleJsBridgeRequest_%@_%@:port:"</span>, module, method]);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:selector]) &#123;</span><br><span class="line">        <span class="keyword">id</span>&lt;QDJSWebViewProtocol&gt; webViewController = [env objectForKey:kJSPluginEnvWebViewController];</span><br><span class="line">        <span class="keyword">self</span>.webViewController = webViewController;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSDictionary</span>*, <span class="built_in">NSNumber</span> *))objc_msgSend)(<span class="keyword">self</span>, selector, query, port);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2><span id="wei-wan-dai-xu">未完待续</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lu-you-jie-ou-shi-sha&quot;&gt;路由解耦是啥？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lu-you-jie-ou-neng-jie-jue-shi-me&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
