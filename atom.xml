<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wtttttt天</title>
  <subtitle>码农的幸福生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanwt.com/"/>
  <updated>2017-06-30T02:28:05.000Z</updated>
  <id>http://fanwt.com/</id>
  
  <author>
    <name>Wtttttt天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS-初识ARKit</title>
    <link href="http://fanwt.com/2017/06/29/iOS-%E5%88%9D%E8%AF%86ARKit/"/>
    <id>http://fanwt.com/2017/06/29/iOS-初识ARKit/</id>
    <published>2017-06-29T02:29:53.000Z</published>
    <updated>2017-06-30T02:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc">

<!-- toc -->
<ul>
<li><a href="#chu-shi-arkit">初识ARKit</a><ul>
<li><a href="#jia-gou-tu">架构图</a></li>
<li><a href="#chang-jing-shi-bie">场景识别</a><ul>
<li><a href="#ping-mian-jian-ce-plane-detection">平面检测（Plane detection）</a></li>
<li><a href="#peng-zhuang-ce-shi-hit-testing">碰撞测试（Hit-testing）</a></li>
<li><a href="#gao-guang-gu-suan-light-estimation">高光估算（Light Estimation）</a></li>
</ul>
</li>
<li><a href="#demo">Demo</a><ul>
<li><a href="#guan-fang-3d-fei-ji-mo-xing-ar-ti-yan">官方3D飞机模型AR体验</a></li>
</ul>
</li>
<li><a href="#zong-jie">总结</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p></div></p>
<h1 id="chu-shi-arkit"><a href="#初识ARKit" class="headerlink" title="初识ARKit"></a>初识ARKit</h1><p>Apple在2017WWDC发布会上带来了全新的iOS11，其中最令人瞩目的是引入了ARKit，这是一个新框架，可以让开发者轻松创建无与伦比的iPhone和iPad增强实现体验。通过将虚拟场景与周围的环境融合，ARKit将应用程序超越屏幕，让它们以全新的方式与现实世界进行交互。</p>
<h2 id="jia-gou-tu"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>用一张图来展示ARKit框架在应用架构中所处在的位置和功能说明：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-1" alt="ARKit框架在应用架构中所处的位置"></p>
<p>从上图可知，Apple提供的AR平台底层主要分为2部分：数据分析处理和渲染。<br>ARKit负责数据分析处理，生成AR体验必要的支撑数据，渲染部分Apple提供了3个框架来支持，它们分为两部分：<br>标准渲染视图：SceneKit和SpriteKit，前者提供3D渲染支持，后者提供2D渲染支持。<br>自定义渲染视图：如果觉得Apple提供的标准渲染视图不满足自己的需求，Apple提供了Metal自定义渲染视图框架，来支持自定义渲染视图。</p>
<p>再来看看ARKit的架构图：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-2" alt="ARKit框架图"></p>
<p>从上图可知，ARKit框架底层主要功能为追踪，分为2块：摄像头画面实时捕捉视频帧；设备感应硬件检测到的动作数据。<br>ARKit将这2者的数据结合起来分析，生成最终结果，再配合渲染库将2D和3D元素内容实时的显示到用户设备实时的摄像画面中，能使用户体验到AR的错觉乐趣，这些2D或3D元素内容从画面中看上去就像是真实世界中的一部分。</p>
<p>架构图看完后，再看看ARKit数据处理的主要流程图：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-3" alt="ARKit数据处理流程图"></p>
<p>从上图流程图中可知，ARKit的核心是ARSession，它管理着AVCaptureSession和CMMotionManager。<br>AVCaptureSession是AVFoundation的核心类，主要用于捕捉视频和音频，协调视频和音频的输入、输出流。<br>CMMotionManager是用于对设备运动识别的，它有2种采样方式：</p>
<p>PUSH：实时采集所需数据，采样频率高。<br>PULL：在有需要的时候，才去采集数据。<br>要运行一个Session，必须要传入一个ARSessionConfiguration配置，运行中的Session会连续地从AVCaptureSession中捕获实时的摄像画面，再结合CMMotionManager提供的运动数据，最终预测出设备的实际位置。</p>
<h2 id="chang-jing-shi-bie"><a href="#场景识别" class="headerlink" title="场景识别"></a>场景识别</h2><p>Apple在WWDC大会上展示了ARKit强大的场景识别能力，视频中有两个让人印象特别深刻的地方：<br>1.演讲者使用一个iPhone手机演示将一个逼真的AR战地场景展示在现场桌面上，其中一个小人为了躲避飞机扔下的炮弹，从桌上跳了下去，刚开始以为这仅仅是WWDC现场演示时Demo故意给人错觉的一种演讲效果，但后来回看了下官方文档，确实有提及ARKit是可以捕捉到多个平面的，以及在后来的演示中有看到DEBUG工具展示多个平面网格。<br>2.另一个<a href="https://developer.apple.com/videos/play/wwdc2017/609/" target="_blank" rel="external">SpriteKit大会讲解视频</a>(PS:在视频24分)时，视频中游戏演示的小人跳到了桌面上的平层，能够在真实世界的平层上来回走动，是不是很震惊！！！</p>
<p>从官方的PPT上看到ARKit在场景识别中有3项重要的技术，分别是：</p>
<ul>
<li>平面检测（Plane detection）</li>
<li>碰撞测试（Hit-testing）</li>
<li>亮度估量（Light estimation）</li>
</ul>
<h3 id="ping-mian-jian-ce-plane-detection"><a href="#平面检测（Plane-detection）" class="headerlink" title="平面检测（Plane detection）"></a>平面检测（Plane detection）</h3><p>PPT中概括了4点：</p>
<ol>
<li>能检测到相对于重力的水平面，即它能检测的出平面的高低落差层次。</li>
<li>可以运行多个帧，如果没理解错的话，应该就是可以同时分析检测出多个平面。</li>
<li>可以对齐置平面的表面上，即当你放置3D精灵视图时，能自动的将3D精灵视图平放到对应的平面上，使它看上去就是像现实中物体放在平面上一样。</li>
<li>进行平面合并。</li>
</ol>
<p>上述可能不是很好理解，用一张图来概括：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-4" alt="ARKit数据处理流程图"></p>
<p>开启平面检测很方便，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Enable plane detection on a session</span></div><div class="line"></div><div class="line"><span class="comment">// Create a new world tracking configuration</span></div><div class="line"><span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingSessionConfiguration</span>()</div><div class="line"></div><div class="line"><span class="comment">// Enable plane detection</span></div><div class="line">configuration.planeDetection = .horizontal</div><div class="line"></div><div class="line"><span class="comment">// Change configuration on currently running session</span></div><div class="line">mySession.run(configuration)</div></pre></td></tr></table></figure></p>
<p>ARWorldTrackingSessionConfiguration类是ARSessionConfiguration类的子类。<br>翻看官方文档可知：<br>ARSessionConfiguration类提供3个自由度（DOF）追踪设备的运动：具体来说，三个旋转轴（滚动，俯视和偏航），它支持所有iOS设备上使用ARKit。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-12" alt="ARSessionConfiguration 3DOF"></p>
<p>ARWorldTrackingSessionConfiguration类是AR体验增强类，对iOS设备要求比较高，需要CPU不低于A9，也就是目前市面上最低iPhone 6s，它提供6个自由度（DOF）追踪设备的运动，比其父类多了3个自由度：三个坐标系（在x、y、z轴上运动）。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-13" alt="ARWorldTrackingSessionConfiguration 6DOF"></p>
<h3 id="peng-zhuang-ce-shi-hit-testing"><a href="#碰撞测试（Hit-testing）" class="headerlink" title="碰撞测试（Hit-testing）"></a>碰撞测试（Hit-testing）</h3><p>PPT中概括了4点：</p>
<ol>
<li>使用真实世界的相交射线。</li>
<li>使用场景信息。</li>
<li>结果按照远近距离排序。</li>
<li>有4种碰撞测试类型来帮助判断碰撞测试结果。</li>
</ol>
<p>Hit-testing会去检测分析出相机图像中的水平面，然后生成其位置和大小的数据。可以把它想象为，摄像头发射一个射线出去，射线碰撞检测到一个点，那么收集到足够多的点就能分析出平面，最终生成返回数据。</p>
<p>如图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-9" alt="Hit-testing"></p>
<p>基于Hit-testing建立一个锚点，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adding an ARAnchor based on hit-test</span></div><div class="line"><span class="keyword">let</span> point = <span class="type">CGPoint</span>(x:<span class="number">0.5</span>, y:<span class="number">0.5</span>) <span class="comment">// Image center</span></div><div class="line"></div><div class="line"><span class="comment">// Perform hit-test on frame</span></div><div class="line"><span class="keyword">let</span> results = frame.hitTest(point, types:[.existingPlane, .estimatedHorizontalPlane])</div><div class="line"></div><div class="line"><span class="comment">// Use the first result</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> closestResult = results.first &#123;</div><div class="line"></div><div class="line">	<span class="comment">// Create an Anchor for it</span></div><div class="line">	<span class="keyword">let</span> anchor = <span class="type">ARAnchor</span>(transform: closestResult.worldTansform)</div><div class="line"></div><div class="line">	<span class="comment">// Add it to the session</span></div><div class="line">	session.add(anchor: anchor)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ARSKView、ARSCNView、ARFrame类中提供了hitTest方法，用于碰撞测试检测分析出平面，方法返回一组ARHitTestResult对象，该方法传入2个参数，第一个参数为CGPoint点，第二个参数为检测碰撞结果的类型，有4种：</p>
<ol>
<li>ARHitTestResult.ResultType.featurePoint，根据距离最近的特征点检测出来的连续表面。</li>
<li>ARHitTestResult.ResultType.estimatedHorizontalPlane，非精准方式计算出来与重力垂直的平面。</li>
<li>ARHitTestResult.ResultType.existingPlane，已经检测出来的平面，检测时忽略平面本身大小，把它看做一个无穷大的平面。</li>
<li>ARHitTestResult.ResultType.existingPlaneUsingExtent，已经检测出来的平面，检测时考虑平面本身的大小。<br>这4种类型可以用|来同时传入。</li>
</ol>
<h3 id="gao-guang-gu-suan-light-estimation"><a href="#高光估算（Light-Estimation）" class="headerlink" title="高光估算（Light Estimation）"></a>高光估算（Light Estimation）</h3><p>在AR增强视觉体验中，如果虚拟内容的高光与环境不符，那还是挺容易看得出这就是一个虚拟物体的。<br>ARKit提供来一个检测视频图像环境光照强度的功能，主要是为了让3D模型的光照与环境的光照强度保持一致。<br>ARKit默认开启了这项检测，且流明度默认值为1000。</p>
<p>用图来展示ARKit强大的魅力：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-7" alt="Light Estimation 1"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-8" alt="Light Estimation 2"></p>
<h2 id="demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="guan-fang-3d-fei-ji-mo-xing-ar-ti-yan"><a href="#官方3D飞机模型AR体验" class="headerlink" title="官方3D飞机模型AR体验"></a>官方3D飞机模型AR体验</h3><p>在Xcode9 beta1中，官方在模板工程中提供了2个示例：SceneKit和SpriteKit，前者3D，后者2D。<br>在Xcode9 beta2中，官方在模板工程中又新增了1个Metal的示例，可以使用Metal技术来自定义渲染视图，该种实现方式比SceneKit和SpriteKit这两种方式复杂的多，<a href="https://developer.apple.com/documentation/arkit/displaying_an_ar_experience_with_metal" target="_blank" rel="external">具体细节请参阅官方文档</a>。</p>
<p>你可以新建一个工程，选择AR模版，在Content Technology中选择使用SceneKit或SpriteKit或Metal，这里选用SceneKit。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-10" alt="Demo 1"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-11" alt="Demo 1"></p>
<p>模板工程很简单，如下图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-14" alt="Demo 1"></p>
<p>art.scnassets为AR素材资源目录，官方提供了一个飞机建模：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-15" alt="Demo 1"></p>
<p>ViewController.swift中的代码如下（删去了暂时无用的空代理回调方法）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"><span class="keyword">import</span> SceneKit</div><div class="line"><span class="keyword">import</span> ARKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        <span class="comment">// Set the view's delegate</span></div><div class="line">        sceneView.delegate = <span class="keyword">self</span></div><div class="line"></div><div class="line">        <span class="comment">// Show statistics such as fps and timing information</span></div><div class="line">        sceneView.showsStatistics = <span class="literal">true</span></div><div class="line"></div><div class="line">        <span class="comment">// Create a new scene</span></div><div class="line">        <span class="keyword">let</span> scene = <span class="type">SCNScene</span>(named: <span class="string">"art.scnassets/ship.scn"</span>)!</div><div class="line"></div><div class="line">        <span class="comment">// Set the scene to the view</span></div><div class="line">        sceneView.scene = scene</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</div><div class="line"></div><div class="line">        <span class="comment">// Create a session configuration</span></div><div class="line">        <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingSessionConfiguration</span>()</div><div class="line"></div><div class="line">        <span class="comment">// Run the view's session</span></div><div class="line">        sceneView.session.run(configuration)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</div><div class="line"></div><div class="line">        <span class="comment">// Pause the view's session</span></div><div class="line">        sceneView.session.pause()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码解读：</p>
<ol>
<li>渲染模块使用ARSCNView视图，它支持3D模型渲染。</li>
<li>在viewDidLoad中设置sceneView的代理，以及现实FPS状态，然后加载飞机3D模型，并将其设置为sceneView的scene属性。</li>
<li>view即将展现时，配置一个ARWorldTrackingSessionConfiguration对象（支持6DOF），将使用该配置来运行Session。</li>
<li>view即将消失时，暂停Session的运行。</li>
</ol>
<p>当你使用A9+设备运行该工程时，会在摄像画面的水平正前方出现一架飞机3D模型，可以像正常拍摄一个物体一样360度查看它，如下图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-16.gif" alt="ARKit-SceneKit-Demo"></p>
<p>简简单单的几行代码便将一个飞机3D模型实时渲染到了实时的视频画面中，还支持6轴运动，不得不说ARKit将AR门槛降低了非常多，使得开发者很轻松地创建出AR体验APP。</p>
<p>官方提供了一个<a href="https://developer.apple.com/sample-code/wwdc/2017/PlacingObjects.zip" target="_blank" rel="external">较为复杂的ARDemo</a>，可以放置一些家具的，画面很逼真，并提供了DEBUG的工具来帮助开发者理解ARKit相关特性，如图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-17" alt="ARKit-SceneKit-Demo"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-18.gif" alt="ARKit-SceneKit-Demo"></p>
<h2 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ARKit支持所有的设备，在CPU A9以下的设别，提供基础的3DOF（滚动，俯视和偏航）支持，在CPU A9及以上，提供6DOF（滚动，俯视和偏航，以及三个坐标系（在x、y、z轴上运动））支持。</p>
<p>ARKit提供了强大的数据分析能力，将实时画面帧与设备运行数据结合，为开发者创建无比惊艳的AR体验APP提供了强大的数据支撑。要开发AR体验APP，需要开发者具备以下知识：</p>
<ol>
<li>线性代数-矩阵计算，推荐一个视频：<a href="http://www.bilibili.com/video/av6731067/" target="_blank" rel="external">线性代数的本质 - 系列合集</a>。</li>
<li>熟悉ARKit框架。</li>
<li>熟悉SceneKit、SpriteKit，这是Apple提供的标准渲染视图，内部处理了绝大部分的渲染处理，能帮助开发者降低渲染AR所具备的知识。</li>
<li>如果要自定义渲染，可以使用Apple提供的Metal框架，今年会发布Metal2，性能进一步提升。</li>
</ol>
<p>可以预测到iOS11正式发布时，将会有众多应用会借势ARKit上首推，特别是游戏类APP，譬如以前大火的植物大战僵尸、水果忍者、宠物精灵、飞行游戏、养成类游戏等等，一般应用中大多数是活动场景，好比：AR抢红包、寻宝、展示等等。</p>
<p>目前正处于Beta阶段的AR体验还有待改进，真机体验的时候，还是能很明显的感受到虚拟物品会漂移或不自然的抖动，慢慢静待Apple的修正吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#chu-shi-arkit&quot;&gt;初识ARKit&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jia-gou-tu&quot;&gt;架构图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chang
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS - 按纯色行切页</title>
    <link href="http://fanwt.com/2017/03/27/iOS-%E6%8C%89%E7%BA%AF%E8%89%B2%E8%A1%8C%E5%88%87%E5%88%86%E9%A1%B5/"/>
    <id>http://fanwt.com/2017/03/27/iOS-按纯色行切分页/</id>
    <published>2017-03-27T15:21:48.000Z</published>
    <updated>2017-03-28T02:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>当前从事阅读类产品开发，开发过程中遇到产品需要在阅读渲染页加各种与阅读正文无关的一些增强用户粘性需求，好比添加：章评、段评、打赏等酷炫的界面。</p>
<p>开发过程中又需要解耦模块，不希望这个新增的页面影响到阅读渲染本身，我这里有一种尝试思路，如有问题希望轻拍。</p>
<p>PS：目前还未运用到实际项目中，只是一个解耦的想法而已💡</p>
<h2 id="jie-jue-si-lu"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol>
<li>如何解决在已渲染好的阅读页中动态加入自定义页，不影响阅读页排版功能，不侵入阅读代码？<br>答：假设自定页面只有一页，且高度就是该阅读页正文显示完剩余的区域，那么直接将自定义页面以addSubView的形式加入到该阅读页。</li>
<li>当自定义页超过一屏时，如何尽可能小影响或不影响阅读翻页逻辑？<br>答：前提：目前我们的阅读框架中每页是否有下一页是一个动态询问过程，翻页手势会询问容器中的当前页是否有前、后一页。修改点：询问逐层传递的思想，修改后，阅读页中有自定义子页时，应优先询问子页是否有下一页，如果有，下一页显示自定义子页，如果没有，再看阅读页自身是否有下一页。</li>
</ol>
<h2 id="he-xin-ru-he-qie-ye"><a href="#核心：如何切页" class="headerlink" title="核心：如何切页"></a>核心：如何切页</h2><p>自定义页面转为像素data，注意不要用高清，节省内存，给一个起始锚点，逐行扫描，当遇到色值不一样时，换行。<br>代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    eFindPureSeparateLinePointDirection_down = <span class="number">0</span>,</div><div class="line">    eFindPureSeparateLinePointDirection_up</div><div class="line">&#125;eFindPureSeparateLinePointDirection;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">WtExt</span>)</span></div><div class="line">- (<span class="built_in">CGPoint</span>)wt_findPureSeparateLinePointWithAnchor:(<span class="built_in">CGPoint</span>)point direction:(eFindPureSeparateLinePointDirection)direction;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">WtExt</span>)</span></div><div class="line">- (<span class="built_in">CGPoint</span>)wt_findPureSeparateLinePointWithAnchor:(<span class="built_in">CGPoint</span>)point direction:(eFindPureSeparateLinePointDirection)direction &#123;</div><div class="line">    <span class="keyword">int</span> preR = <span class="number">-1</span>, preG = <span class="number">-1</span>, preB = <span class="number">-1</span>, preA = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    size_t pixelsWidth = <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.frame);</div><div class="line">    size_t pixelsHeight = <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.frame);</div><div class="line">    <span class="keyword">int</span> x = point.x;</div><div class="line">    <span class="keyword">int</span> y = point.y;</div><div class="line"></div><div class="line">    <span class="built_in">CGFloat</span> scale = <span class="number">1</span>;</div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.frame.size.width*scale, <span class="keyword">self</span>.frame.size.height*scale) ;</div><div class="line">    <span class="keyword">int</span> bitPerRow = size.width * <span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> bitCount = bitPerRow * size.height;</div><div class="line">    <span class="built_in">UInt8</span> *bitdata = malloc(bitCount);</div><div class="line">    <span class="keyword">if</span> (bitdata == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">CGColorSpaceRef</span> deviceRGB = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">    <span class="keyword">if</span> (deviceRGB == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">CGContextRef</span> contex = <span class="built_in">CGBitmapContextCreate</span>(bitdata, size.width, size.height, <span class="number">8</span>, bitPerRow, deviceRGB, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</div><div class="line">    <span class="keyword">if</span> (contex == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">CFRelease</span>(deviceRGB);</div><div class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">CFRelease</span>(deviceRGB);</div><div class="line"></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(contex, <span class="number">0</span>, size.height);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(contex, scale, -scale);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.layer renderInContext:contex];</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = (direction==eFindPureSeparateLinePointDirection_down)?<span class="number">1</span>:<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (y &gt;= pixelsHeight || y &lt; <span class="number">0</span>) &#123;</div><div class="line">            x = <span class="number">-1</span>;</div><div class="line">            y = INT_MAX;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (x &gt;= pixelsWidth) &#123;</div><div class="line">            x = point.x;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> offset = <span class="number">4</span>*((pixelsWidth*round(y))+round(x));</div><div class="line">        <span class="keyword">if</span> (preR == <span class="number">-1</span>) &#123;</div><div class="line">            preR = bitdata[offset];</div><div class="line">            preG = bitdata[offset+<span class="number">1</span>];</div><div class="line">            preB = bitdata[offset+<span class="number">2</span>];</div><div class="line">            preA = bitdata[offset+<span class="number">3</span>];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (preR != bitdata[offset] ||</div><div class="line">                preG != bitdata[offset+<span class="number">1</span>] ||</div><div class="line">                preB != bitdata[offset+<span class="number">2</span>] ||</div><div class="line">                preA != bitdata[offset+<span class="number">3</span>]) &#123;</div><div class="line"></div><div class="line">                x = point.x;</div><div class="line">                y += i;</div><div class="line">                preR = <span class="number">-1</span>, preG = <span class="number">-1</span>, preB = <span class="number">-1</span>, preA = <span class="number">-1</span>;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                x++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CGContextRelease</span>(contex);</div><div class="line">    free(bitdata);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(x, y);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当前从事阅读类产品开发，开发过程中遇到产品需要在阅读渲染页加各种与阅读正文无关的一些增强用户粘性需求，好比添加：章评、段评、打赏等酷炫的界面。&lt;/p&gt;
&lt;p&gt;开发过程中又需要解耦模块，不希望这个新增的页面影响到阅读渲染本身，我这里有一种尝试思路，如有问题希望轻拍。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS - 路由解耦</title>
    <link href="http://fanwt.com/2017/03/24/iOS-JSSDK/"/>
    <id>http://fanwt.com/2017/03/24/iOS-JSSDK/</id>
    <published>2017-03-24T04:54:42.000Z</published>
    <updated>2017-03-25T06:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc">

<!-- toc -->
<ul>
<li><a href="#lu-you-jie-ou-shi-sha">路由解耦是啥？</a></li>
<li><a href="#lu-you-jie-ou-neng-jie-jue-shi-me">路由解耦能解决什么？</a></li>
<li><a href="#ji-zhu-xu-qiu-bei-jing">技术需求背景</a></li>
<li><a href="#zheng-li-ji-zhu-shi-xian-si-lu">整理技术实现思路</a></li>
<li><a href="#yi-hybrid-jssdk">一、Hybrid(JSSDK)</a><ul>
<li><a href="#hybrid-jssdk-de-shi-yong-chang-jing-ji-url-ju-li">Hybrid(JSSDK)的使用场景及URL举例</a></li>
</ul>
</li>
<li><a href="#er-openurl">二、OpenURL</a><ul>
<li><a href="#openurl-yu-dao-de-keng">OpenURL遇到的坑</a></li>
<li><a href="#openurl-de-shi-yong-chang-jing-ji-url-ju-li">OpenURL的使用场景及URL举例</a></li>
</ul>
</li>
<li><a href="#san-universal-links">三、Universal Links</a><ul>
<li><a href="#universal-links-de-shi-yong-chang-jing-ji-url-ju-li">Universal Links的使用场景及URL举例</a></li>
</ul>
</li>
<li><a href="#shi-xian-yao-dian">实现要点</a><ul>
<li><a href="#jie-xi-url-de-ru-kou">解析URL的入口</a></li>
<li><a href="#jie-xi-hou-de-zi-duan-zuo-lu-you-zhuan-fa">解析后的字段作路由转发</a></li>
</ul>
</li>
<li><a href="#wei-wan-dai-xu">未完待续</a></li>
</ul>
<!-- tocstop -->
</div>

<h2 id="lu-you-jie-ou-shi-sha"><a href="#路由解耦是啥？" class="headerlink" title="路由解耦是啥？"></a>路由解耦是啥？</h2><p>路由解耦，故名思意就是使用URL，根据请求地址进行解析，映射到相关代码的逻辑操作，诸如：页面跳转、UI弹层展示、事件分发、IO存储等等，对于调用方来说，使用统一标准化格式的URL协议即可。<br>在iOS端的开发中，使用URL交互的地方无外乎：应用内Web、应用外Web、应用模块间解耦单向通信（双向通信使用模块暴露接口会更佳合理和优雅），本文将从Hybrid(JSSDK)、OpenURL(iOS9-)、Universal Links(iOS9+)三方面阐述路由解耦设计的一些经验和思考。</p>
<h2 id="lu-you-jie-ou-neng-jie-jue-shi-me"><a href="#路由解耦能解决什么？" class="headerlink" title="路由解耦能解决什么？"></a>路由解耦能解决什么？</h2><ol>
<li>应用内Web，使用封装的Hybrid(JSSDK)进行双向通信。</li>
<li>应用外Web，会受到制约：有的APP比较强势，会拦截URL，不允许跳转到外部应用，例如：微信。iOS8目前仍无解(用户占比少)，但iOS9+(用户占比极高)的设备可以使用Universal Links来解决该问题。</li>
<li>应用模块间解耦单向通信，相当于给模块暴露的单向通信接口起一个URL的别名，好处是方便业务部门的人来使用，例如：活动配置，下发URL可以跳转到相应的页面。</li>
</ol>
<h2 id="ji-zhu-xu-qiu-bei-jing"><a href="#技术需求背景" class="headerlink" title="技术需求背景"></a>技术需求背景</h2><ol>
<li>在早期的iOS开发中，经常需要会遇到调用或跳转外部其他App，诸如：在关于联系我们页面中的电话点击事件触发后直接拨打电话、点击email时弹出发送邮件页（预设好接受人email、主题、内容等）、跳转到Apple的设置页、跳转到Sina微博分享等等，Apple在iOS2.0时提供了OpenURL解决方案来支持上述的需求场景。</li>
<li>项目中有很多活动相关的Web页，在Web页面中常常需要获取客户端的信息、调用客户端的原生功能，诸如：获取客户端版本号、打开客户端的原生页面、修改导航栏色值、调用客户端的本地逻辑操作等。</li>
<li>在微信这种强势APP中，OpenURL被它拦截，导致无法跳转自己的APP 的相关功能页。</li>
<li>由于OpenURL的过程没有任何安全性校验，导致APP内支持的OpenURL可能会被任何的App随时呼起，以及滥用其中的功能。Apple考虑到OpenURL安全性不足，于是在iOS9中推出了Universal Links(通用链接)和ATS 隐私控制，不在AASA、ATS白名单的域名统统被拒绝。我们工程最低版本支持iOS8+，Web页在iOS8的设备上能通过OpenURL唤起APP，但iOS9+后，由于未配置Universal Links，导致OpenURL失效，最终无法唤起APP。</li>
</ol>
<h2 id="zheng-li-ji-zhu-shi-xian-si-lu"><a href="#整理技术实现思路" class="headerlink" title="整理技术实现思路"></a>整理技术实现思路</h2><p>Hybrid(JSSDK)、OpenURL、Universal Links三者都是使用URL统一资源定位符来与客户端通信，这三者的通性，利用这一点，只要URL统一规则，客户端就可以无差别的解析处理了。<br>格式定义如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scheme://module:port/method?&#123;query:&#123;&#125;&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>关于scheme，Hybrid(JSSDK)、OpenURL、Universal Links可以使用一致的scheme，一般而言，scheme统一使用项目的scheme即可。Hybrid(JSSDK)使用了scheme为jsbridge来区分这是JSSDK的API。</li>
<li>port，解析后，只有Hybrid(JSSDK)会使用该参数进行OC与JS通信，实现原理很简单，JS提供一个回调方法，port参数用于告知是哪一个事件回调了，就像设置了一个delegate。OpenURL、Universal Links只能URL-&gt;客户端的单向通信，无法回传数据给调用方，即无法使用、也不需要port参数。</li>
<li>module，模块，映射到客户端的哪个模块。</li>
<li>method，方法，映射到客户端的哪个模块的哪个方法。</li>
<li>query，参数，映射到客户端的哪个模块的哪个方法中的参数。</li>
</ol>
<p>不同的iOS版本、应用内、应用外，使用的安全处理机制不一样，解决方案如下：</p>
<ol>
<li>iOS8设备，Hybrid(JSSDK) 有自己单独的域名白名单，可以监管到安全问题；OpenURL可以随意调用，无法监管到安全问题。</li>
<li>iOS9+设备，Hybrid(JSSDK) 有自己单独的域名白名单，可以监管到安全问题；应用内HTTP、Web由ATS监管安全问题；Universal Links使用配置的apple-app-site-association来监管安全问题。<blockquote>
<p><strong>注意：如果开启了ATS功能，iOS9和iOS10还是有些区别的，iOS9中的ATS没有区分本地请求和Web请求，iOS10中考虑到Web无法全部使用ATS的场景，所以如果在项目中开启了ATS并设置了NSExceptionDomains白名单以及开启了NSAllowsArbitraryLoadsInWebContent字段为true，那在iOS9应用内Web会验证白名单，而iOS10应用内Web不会验证白名单，直接使用NSAllowsArbitraryLoadsInWebContent允许全部的web关闭ATS验证。当前iOS端主流最低支持版本为iOS8+，这就需要和客户端合作的Web前端同学注意资源域名要在白名单中才能兼容iOS9的设备Web正常访问资源。</strong></p>
</blockquote>
</li>
</ol>
<h2 id="yi-hybrid-jssdk"><a href="#一、Hybrid-JSSDK" class="headerlink" title="一、Hybrid(JSSDK)"></a>一、Hybrid(JSSDK)</h2><p>关于JSSDK，核心技术有以下几点：</p>
<ol>
<li><p>URL的协议定义，上述讲了，为了避免上翻回去查找，这里再贴一次，格式为：</p>
<blockquote>
<p>scheme://module:port/method?{query:{}}</p>
</blockquote>
</li>
<li><p>使用OC的动态性、以及使用block回调，动态查找类、方法，动态调用方法，动态传入参数，动态性+block的组合很完美。</p>
</li>
<li>利用port字段，在OC回调JS方法时传入，作为delegate使用，这样就支持了OC与JS的双向通信能力。<br>实际编码过程中，JSSDK的核心代码量不超过100行，是不是特别简单容易理解。</li>
</ol>
<h3 id="hybrid-jssdk-de-shi-yong-chang-jing-ji-url-ju-li"><a href="#Hybrid-JSSDK-的使用场景及URL举例" class="headerlink" title="Hybrid(JSSDK)的使用场景及URL举例"></a>Hybrid(JSSDK)的使用场景及URL举例</h3><p>举例双向通信和单向通信，栗子来了：<br>使用场景如下：</p>
<ol>
<li><p>Web页调用JS获取客户端的信息，通过port端口号回调JS方法，好比：获取客户端的VersionCode，如下代码所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//双向通信</span></div><div class="line">jsbridge:<span class="comment">//device:1/versionCode</span></div></pre></td></tr></table></figure>
</li>
<li><p>Web页调用JS设置导航栏右侧按钮，点击按钮后，通过port端口号回调JS方法，好比：设置Web页导航栏右侧按钮为分享，如下代码所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//双向通信</span></div><div class="line">jsbridge:<span class="comment">//ui:2/setHeaderRight?&#123;"query":&#123;"icon":"share"&#125;&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>应用内Web页的JS -&gt; OC 单向通信，好比：Web页中点击封面跳转客户端原生书籍详情页：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//单向通信</span></div><div class="line">jsbridge:<span class="comment">//app/showBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="er-openurl"><a href="#二、OpenURL" class="headerlink" title="二、OpenURL"></a>二、OpenURL</h2><p>OpenURL设计的目的就是解耦模块，我们来看看它能做什么：</p>
<ol>
<li>Apple就提供了若干的功能，诸如：打电话、发邮件、打开AppStore等。</li>
<li>常见的第三方登录模块也用的OpenURL来进行APP间跳转式的双向通信。</li>
<li>APNS推送中可以添加字段URL，用户点击推送后，可以执行相应逻辑，这里能很清楚地看得到模块间的解耦。</li>
<li>桌面APP使用3D Touch时，可以用OpenURL的思路解决模块解耦问题，在设置3D Touch项时，使用OpenURL作为item的描述，这样3D Touch回调事件里只需写一句话：执行OpenURL。</li>
</ol>
<h3 id="openurl-yu-dao-de-keng"><a href="#OpenURL遇到的坑" class="headerlink" title="OpenURL遇到的坑"></a>OpenURL遇到的坑</h3><p>实际使用过程中，我发现Apple的OpenURL效率并不高，在某些场景下速度慢的惊人，譬如上述它能做什么中的第4点，如果在3D Touch回调中直接使用Apple的OpenURL方法，真机上看到的现象是进入APP奇慢无比，像是卡住了一样。3D Touch回调事件代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler &#123;</div><div class="line">    <span class="built_in">NSString</span> *urlString = shortcutItem.type;</div><div class="line">    <span class="keyword">if</span> (urlString.length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:[urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决办法也很简单：<br>其实想想就知道OpenURL是用于APP外部调用的，在我们APP应用内直接走解析URL和动态执行方法就好了。改进后的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler &#123;</div><div class="line">    <span class="built_in">NSString</span> *urlString = shortcutItem.type;</div><div class="line">    <span class="keyword">if</span> (urlString.length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    [<span class="keyword">self</span> qd_handleActionUrl:[<span class="built_in">NSURL</span> URLWithString:[urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="openurl-de-shi-yong-chang-jing-ji-url-ju-li"><a href="#OpenURL的使用场景及URL举例" class="headerlink" title="OpenURL的使用场景及URL举例"></a>OpenURL的使用场景及URL举例</h3><p>使用场景如下：</p>
<ol>
<li><p>应用内部调用URL路由作模块解耦，好比：书籍详情页调用加书架功能：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QD:<span class="comment">//app/addToBookshelf?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>APNS推送点击后可以响应客户端本地事件，好比：用户收到了一条热门书籍推送，点击推送后跳转客户端原生书籍详情页：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QD:<span class="comment">//app/showBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="san-universal-links"><a href="#三、Universal-Links" class="headerlink" title="三、Universal Links"></a>三、Universal Links</h2><p>这里讲到它的目的，是以下2点：</p>
<ol>
<li>在iOS9+时，Apple提出了ATS的要求，以前的OpenURL在Web前端可以随意被其他APP滥用，没有任何的安全机制保护，于是推出了Universal Links来增加OpenURL在Web前端的安全合法校验，只有域名验证通过的链接，才能使用OpenURL打开APP。</li>
<li>微信中拦截了URL，不让跳转到外部应用中。但Universal Links是系统级别的，可以绕过微信的拦截限制。</li>
</ol>
<p>它和Hybrid(JSSDK)、OpenURL的URL格式有所区别，它的格式如下：<br>PS: 由于Universal Links只作单向通信，所以我们忽略port参数(port参数的目的就是作为双向通信delegate)。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scheme:<span class="comment">//host/route/module/method?&#123;query:&#123;&#125;&#125;</span></div></pre></td></tr></table></figure></p>
<p>它的区别在于:它多出来了host/route，除了这一点，其他格式和Hybrid(JSSDK)、OpenURL的URL毫无差别，所以当客户端接收到URL时，过滤掉host/route就可以了。</p>
<h3 id="universal-links-de-shi-yong-chang-jing-ji-url-ju-li"><a href="#Universal-Links的使用场景及URL举例" class="headerlink" title="Universal Links的使用场景及URL举例"></a>Universal Links的使用场景及URL举例</h3><p>使用场景如下：</p>
<ol>
<li><p>iOS9+在Web前端的链接，好比：书籍详情页调用加书架功能：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QD:<span class="comment">//qidian.com/reader/app/addToBookshelf?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>微信中点击链接打开客户端原生页面， 好比：微信公众号里分享了一本经典小说，点击后跳转打开客户端原生阅读页：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QD:<span class="comment">//qidian.com/reader/app/openBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="shi-xian-yao-dian"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><h3 id="jie-xi-url-de-ru-kou"><a href="#解析URL的入口" class="headerlink" title="解析URL的入口"></a>解析URL的入口</h3><p>Hybrid(JSSDK)、OpenURL、Universal Links 3者处理URL入口不一样，具体如下：</p>
<ol>
<li><p>Hybrid(JSSDK)在UIWebView的delegate回调中拦截URL进行特殊处理，如果Hybrid(JSSDK)拦截成功，则直接返回NO，打断UIWebView自身的处理逻辑；否则返回YES，继续UIWebView的处理逻辑，方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)webView:shouldStartLoadWithRequest:navigationType:</div></pre></td></tr></table></figure>
</li>
<li><p>OpenURL，在AppDelegate的回调中处理解析URL，iOS8与iOS9的有所区别，如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//iOS9代理回调方法</span></div><div class="line">-(<span class="built_in">BOOL</span>)application:openURL:options:</div><div class="line"></div><div class="line"><span class="comment">//iOS8代理回调方法</span></div><div class="line">-(<span class="built_in">BOOL</span>)application:openURL:sourceApplication:annotation:</div></pre></td></tr></table></figure>
</li>
<li><p>Universal Links，在AppDelegate的回调中处理解析URL，方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需要注意一点的是，通用链接过来的URL，会带有host/route，在代理方法中需要过滤掉host/route，将格式统一为scheme://module/method?&#123;query:&#123;&#125;&#125;</span></div><div class="line">-(<span class="built_in">BOOL</span>)application:continueUserActivity:restorationHandler:</div></pre></td></tr></table></figure>
</li>
<li><p>暴露了一个C函数，方便跨模块调用，主要用于解耦目的。目前只支持单向通信（考虑到双向通信会增加复杂度，使用模块对外暴露接口更优雅，所以暂不考虑双向通信）。举例，调用方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QDRouteBridge(<span class="string">@"QDReader://app/addToBookshelf?&#123;\"query\":&#123;\"bookId\": 1004976324&#125;&#125;"</span>)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="jie-xi-hou-de-zi-duan-zuo-lu-you-zhuan-fa"><a href="#解析后的字段作路由转发" class="headerlink" title="解析后的字段作路由转发"></a>解析后的字段作路由转发</h3><p>当成功解析了scheme、port、module、method、query部分后，iOS客户端会通过module映射到一个类名，method映射到其中的一个具体方法，query、port这2个作为传入参数，然后执行该方法。<br>总结关键执行步骤：</p>
<ol>
<li>映射到具体的类。</li>
<li>拼接方法名。</li>
<li>利用OC语言的动态性，动态调用方法。<br>关键的代码部分：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)qd_handleJsRequest:(<span class="built_in">NSURL</span> *)request module:(<span class="built_in">NSString</span> *)module method:(<span class="built_in">NSString</span> *)method port:(<span class="built_in">NSNumber</span> *)port query:(<span class="built_in">NSDictionary</span> *)query fromEnv:(<span class="built_in">NSDictionary</span> *)env &#123;</div><div class="line">    <span class="keyword">if</span> (!request ||</div><div class="line">        !module ||</div><div class="line">        !method) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"qd_handleJsBridgeRequest_%@_%@:port:"</span>, module, method]);</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:selector]) &#123;</div><div class="line">        <span class="keyword">id</span>&lt;QDJSWebViewProtocol&gt; webViewController = [env objectForKey:kJSPluginEnvWebViewController];</div><div class="line">        <span class="keyword">self</span>.webViewController = webViewController;</div><div class="line"></div><div class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSDictionary</span>*, <span class="built_in">NSNumber</span> *))objc_msgSend)(<span class="keyword">self</span>, selector, query, port);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="wei-wan-dai-xu"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lu-you-jie-ou-shi-sha&quot;&gt;路由解耦是啥？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lu-you-jie-ou-neng-jie-jue-shi-me&quot;&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
