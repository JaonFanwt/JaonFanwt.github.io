<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wtttttt天</title>
  
  <subtitle>码农的幸福生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanwt.com/"/>
  <updated>2017-12-08T07:53:27.503Z</updated>
  <id>http://fanwt.com/</id>
  
  <author>
    <name>Wtttttt天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS11中UITableViewCell不能侧滑编辑的诡异问题</title>
    <link href="http://fanwt.com/2017/12/08/iOS11%E4%B8%ADUITableViewCell%E4%B8%8D%E8%83%BD%E4%BE%A7%E6%BB%91%E7%BC%96%E8%BE%91%E7%9A%84%E8%AF%A1%E5%BC%82%E9%97%AE%E9%A2%98/"/>
    <id>http://fanwt.com/2017/12/08/iOS11中UITableViewCell不能侧滑编辑的诡异问题/</id>
    <published>2017-12-08T07:32:01.000Z</published>
    <updated>2017-12-08T07:53:27.503Z</updated>
    
    <content type="html"><![CDATA[<p>组员反馈项目中有一个诡异的问题，在iOS11中，工程中所有页面的UITableViewCell第一次能侧滑编辑，只要停留在该页面，之后再也无法侧滑编辑，但是仍旧能断点到代理方法中。<br>当时第一反应是怀疑工程中大量的Swizzle方法，庞大的工程也不知从何查起，抱着运行项目看看日志提示，碰碰运气的心态run了项目跑在模拟器中，在第一次侧滑编辑时无异样，滚屏退出编辑态，第二次侧滑时，tableview就无法应了，但好在日志中发现了痕迹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;prepareWithSwipeDirection:configuration:&apos;.  Signature thinks it does not return a struct, and compiler thinks it does.</span><br></pre></td></tr></table></figure></p><p>大致意思是方法签名描述不一致，也就是约定返回一个struct的，但并没有返回struct类型。</p><p>习惯性的去Google上查找资料发现<a href="https://github.com/Desgard/iOS-Source-Probe/blob/master/Objective-C/Runtime/objc_msgSend%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.md" target="_blank" rel="noopener">链接</a><br>在其中找到了__forwarding__的分析代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">if (signatureIsStret != isStret) &#123;</span><br><span class="line">    CFLog(kCFLogLevelWarning ,</span><br><span class="line">      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</span><br><span class="line">      selName,</span><br><span class="line">      signatureIsStret ? &quot;&quot; : not,</span><br><span class="line">      isStret ? &quot;&quot; : not);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更加怀疑是项目中swizzle的方法惹的祸了</p><p>怀疑的步骤为：</p><ol><li>先怀疑NSObject的methodSignatureForSelector方法，屏蔽掉工程中Swizzle的代码，发现并没解决问题。</li><li>怀疑之前解决数组和字典的nil问题，屏蔽掉所有数组和字典的swizzle方法，发现问题解决。</li><li>一个个大块放开代码检查，最终定位。</li></ol><p>罪魁祸首：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSMutableDictionary (NilSafe)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = NSClassFromString(@&quot;__NSDictionaryM&quot;);</span><br><span class="line">        [class gl_swizzleMethod:@selector(setObject:forKeyedSubscript:) withMethod:@selector(gl_setObject:forKeyedSubscript:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)gl_setObject:(id)obj forKeyedSubscript:(id&lt;NSCopying&gt;)key &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!obj) &#123;</span><br><span class="line">        obj = [NSNull null];</span><br><span class="line">    &#125;</span><br><span class="line">    [self gl_setObject:obj forKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>拦截了系统的字典，将obj为nil时替换成了NSNull，怀疑是组员从网上拷贝的代码来解决服务端下发数据中有nil的问题。如果是为了解决数组、字典中nil数据导致的crash问题，那判断到!obj时，直接return就好了。</p><p>最终解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!obj) &#123;</span><br><span class="line">    obj = [NSNull null];</span><br><span class="line">&#125;</span><br><span class="line">// 更改为</span><br><span class="line">if (!obj) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>个人觉得NSNull尽量少用，它一般用在闭环逻辑的代码中，也就是自己能掌控的闭环逻辑中，用它来标记、处理空逻辑行为。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组员反馈项目中有一个诡异的问题，在iOS11中，工程中所有页面的UITableViewCell第一次能侧滑编辑，只要停留在该页面，之后再也无法侧滑编辑，但是仍旧能断点到代理方法中。&lt;br&gt;当时第一反应是怀疑工程中大量的Swizzle方法，庞大的工程也不知从何查起，抱着运行项
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>制作OC与Swift混编的动态framework</title>
    <link href="http://fanwt.com/2017/12/06/%E5%88%B6%E4%BD%9COC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96%E7%9A%84%E5%8A%A8%E6%80%81framework/"/>
    <id>http://fanwt.com/2017/12/06/制作OC与Swift混编的动态framework/</id>
    <published>2017-12-06T07:47:27.000Z</published>
    <updated>2017-12-08T02:42:40.004Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="zhi-zuo-oc-yu-swift-hun-bian-de-dong-tai-framework">制作OC与Swift混编的动态framework</span></h1><p>在iOS开发过程中，会遇到如下场景：</p><ol><li>编写私有库。</li><li>私有库对内开放，对外需要打包成framework或static library。</li></ol><p>注：制作Swift库需是动态framework，本篇介绍都针对framework来展开讨论。</p><p>在Cocoapods还未出现之前，开发都是使用Xcode来手动创建库工程，这种方式较原始且复杂，工程接入源码和framework来调试的步骤太多，不易管理和维护。<br>Cocoapods的出现帮助了开发者管理和创建依赖库，它简单易用，只需要简单的命令和配置就能导入第三方库，或是创建一个带有Demo且带有单元测试的库工程，这样便利的依赖库管理工具极大地提升了开发者的开发效率。</p><p>本文将介绍使用Cocoapods来制作OC与Swift的动态framework。<br>（Cocoapods有一个cocoapods-packager工具，需额外地安装，但实际使用中发现它不是这么的简单易用。）</p><p>以WtCore库工程来举例，打开WtCore.xcworkspace，工程目录结构如下：<br><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512541980320.png" width="50%" height="50%"><br>command+B编译好后，可以右键Show in Finder找到WtCore.framework，目录结构如下：<br><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512542299702.png" width="100%" height="100%"></p><ul><li>Debug-iphoneos是真机的动态framework</li><li>Debug-iphonesimulator是模拟器的动态framework</li></ul><p>将这2个framework合并成一个framework，同时对模拟器和真机进行支持。<br>拷贝这2个framework至tmp目录中，结构如下：<br><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512542727585.png" width="100%" height="100%"></p><p>打开终端，进入到tmp路径下，执行以下命令来合并生成执行文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -create ./Debug-iphoneos/WtCore.framework/WtCore ./Debug-iphonesimulator/WtCore.framework/WtCore -output WtCore</span><br></pre></td></tr></table></figure></p><p>执行完后会在tmp目录中生成合并后的WtCore执行文件，可以使用如下命令查看可执行文件支持的架构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -info WtCore.framework/WtCore</span><br></pre></td></tr></table></figure></p><p><img src="/2017/12/06/制作OC与Swift混编的动态framework/1512543011293.png" width="100%" height="100%"></p><p>合并完可执行文件后，继续执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -a Debug-iphoneos/WtCore.framework ./</span><br><span class="line">$ mv -f WtCore WtCore.framework/WtCore</span><br><span class="line">$ cp -a Debug-iphonesimulator/WtCore.framework/Modules/WtCore.swiftmodule/* WtCore.framework/Modules/WtCore.swiftmodule</span><br></pre></td></tr></table></figure></p><p>此时tmp下的WtCore.framework就是我们要的OC与Swift混编动态framework，该framework依赖的第三方库并未打包到库中，第三方使用时需要额外导入，可以README.md中说明，或是使用Cocoapods来配置该framework的第三方依赖关系。</p><p>这种制作OC与Swift混合动态framework同样适用于制作独立OC或独立Swift的库工程。<br>最后附上<a href="https://github.com/JaonFanwt/OCTestCoreFramework" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;zhi-zuo-oc-yu-swift-hun-bian-de-dong-tai-framework&quot;&gt;制作OC与Swift混编的动态framework&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在iOS开发过程中，会遇到如下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写私
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从Delegate到DelegateBlock</title>
    <link href="http://fanwt.com/2017/08/04/%E4%BB%8EDelegate%E5%88%B0DelegateBlock/"/>
    <id>http://fanwt.com/2017/08/04/从Delegate到DelegateBlock/</id>
    <published>2017-08-04T15:42:00.000Z</published>
    <updated>2017-12-06T07:58:14.773Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="cong-delegate-dao-delegateblock">从Delegate到DelegateBlock</span></h1><p>在iOS开发中常与各种delegate打交道，这种代理委托协议的开发模式学习成本很低且扩展性特别强，本文就将在delegate开发模式的基础上进一步扩展它，从Delegate转换到DelegateBlock的模式。</p><p><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_0.png" alt="Alt text"></p><p>用一张图来展示这种Delegate转换到DelegateBlock的对比：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_1.png" alt="Alt text"></p><p>改造前，实现协议的步骤如下：</p><ol><li>在类名后标记协议名。</li><li>在类中添加并实现委托协议方法。</li></ol><p>扩展后，实现协议的步骤如下：</p><ol><li>创建一个DelegateBlock代理对象。</li><li>代理对象绑定委托协议selector与block。</li></ol><p>从上述可看出改造前后有一点很大的区别：改造后的委托协议绑定方法是可以替换的，而改造前在类中添加方法的这种就只能用继承或者动态替换方法的办法来替换对应的逻辑的，什么？没看懂？举个栗子：你写了一个代理对应的若干委托方法实现，该段代码将在项目内很多地方被使用，但是有几处将会在某一个或几个委托方法有完全不一样的处理逻辑，如果用传统的delegate处理逻辑，那就需要继承类重写委托方法了，如果有一个对象，能和设置属性一样方便的设置一个block与select的mapping关系，当委托方法被调用时，替换成执行block，那就能轻松解决这个代码重用问题。</p><p>什么？还是没看懂？用代码吧：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_2.png" alt="Alt text"></p><p>PS：WtDelegateProxy类的灵感来至于RACDelegateProxy。</p><p>WtDelegateProxy类只支持一个协议（代码结构更清晰），它有一个绑定selector与block的方法，当绑定完后，delegate调用selector时，会触发消息转发行为，将在内部执行block方法，从而实现delegate到delegateBlock的转换。</p><p>流程如图所示：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_3.png" alt="Alt text"></p><p>它能干什么呢？<br>先来看一下iOS端开发最为常见的一个UI组建：UITableView，UITableView是Apple提供的UI滚动单元格控件，可以说是iOS开发中使用频率最高的控件，日常使用的APP诸如QQ、微信、网易新闻等软件中大量使用了该控件，它能给用户带来极佳的用户体验。</p><p>UITableView的性能极高，提供给开发者的API也非常容易上手，它提供了UITableViewDataSource和UITableViewDelegate两个代理类，前者是数据源代理，UITableView会从它委托的代理方法中获取数据，后者是一般代理，UITableView的生命周期事件以及交互事件等都会回调到它委托的代理方法。</p><p>通常UITableView中只有一种Cell类型的时候，代码会特别的简洁和清晰，一旦Cell类型巨增的时候，委托代理方法中的逻辑将变得十分可怕，看看如下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span> (indexPath.section == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexPath.row == <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (indexPath.row == <span class="number">1</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (indexPath.section == <span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>项目中这样的需求并不少见，就拿起点读书APP来说，诸如：精选页、书籍详情页、账户页。如果TableView中的cell出现组合策略的话，其中的逻辑会变的更加复杂，使用上述的这种判断indexPath的办法显得十分笨拙以及难以维护，甚至一不小心就会出现数据源与UI刷新不一致从而导致崩溃。</p><p>接下来一起来看看如何从容优雅地使用它来实现UITableView，改造后：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_4.png" alt="Alt text"></p><p>流程如下：<br><img src="/2017/08/04/从Delegate到DelegateBlock/delegateBlock_5.png" alt="Alt text"></p><p>也就是将TableView的数据源由Model换为ViewModel，ViewModel只干一件事：双向数据绑定！UIViewController中的代理方法也只干一件事：取出ViewModel，然后调用对应的代理方法。</p><p>在ViewModel中绑定对应协议委托方法，这些方法有对应的Cell如何创建、多高、点击事件、3DTouch重压事件，该ViewModel可以提供给组内其他开发人员使用，只需要设置一些数据字段，就可以简单的展示在TableView上，如果你需要一个不一样的点击事件，可以将ViewModel中的delegate对象重新设置selector与block的绑定关系即可。</p><p>最后<a href="https://github.com/JaonFanwt/WtCellModel" target="_blank" rel="noopener">Demo地址</a>奉上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;cong-delegate-dao-delegateblock&quot;&gt;从Delegate到DelegateBlock&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在iOS开发中常与各种delegate打交道，这种代理委托协议的开发模式学习成本很低且扩展性特别强，本文就将在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Shadowsocks科学上网</title>
    <link href="http://fanwt.com/2017/07/02/%E4%BD%BF%E7%94%A8Shadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://fanwt.com/2017/07/02/使用Shadowsocks科学上网/</id>
    <published>2017-07-02T15:28:18.000Z</published>
    <updated>2017-07-02T15:40:59.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jian-jie">简介</a></li><li><a href="#zhi-shi-dian">知识点</a></li><li><a href="#vultr-shadowsocks-tcpspeed-fen-bie-shi-shi-me">Vultr + Shadowsocks + tcpspeed 分别是什么？</a></li><li><a href="#kai-xiao">开销</a></li><li><a href="#vultr-jia-de-vps">Vultr家的VPS</a><ul><li><a href="#zhu-ce-vultr-zhang-hao">注册Vultr账号</a></li></ul></li><li><a href="#macos-shang-an-zhuang-shadowsocks-ke-hu-duan">macOS上安装Shadowsocks客户端</a></li><li><a href="#tcpspeed-gou-mai-vultr-fu-wu-duan-bu-shu">tcpspeed购买 + Vultr服务端部署</a></li><li><a href="#hui-dao-macos-she-zhi-tcpspeed-ke-hu-duan">回到macOS设置tcpspeed客户端</a></li></ul><!-- tocstop --><p></div></p><h2><span id="jian-jie">简介</span></h2><p>码农一枚<br>工作所需，许多技术问题在Google上一查便知，大大地帮助了我解决各种技术疑难杂症<br>Gmail，个人觉得最最最好用的邮箱，但国内经常无法登录<br>偶尔上下油管、tumblr小小的怡情一下，速度嘛要求必须高，时间便是金钱~</p><p>尝试过购买商家VPN，也中转过几家，总结有以下几个缺点：</p><ol><li>价格贵。</li><li>有流量限制，流量越高，价格越高。</li><li>不稳定，看油管1080P跑不动。</li><li>连接设备数量限制。</li><li>商家说不定哪天就跑路啦，哈哈。</li></ol><p>在查询了各种资料后，最终选择了以下组合方案：<br>Vultr + Shadowsocks + tcpspeed</p><p>该组合能将带宽利用最大化，看油管、tumblr高清视频毫无压力。</p><h2><span id="zhi-shi-dian">知识点</span></h2><p>看完本篇文章，你将学会以下技能：</p><ol><li>注册并购买VPS（推荐Vultr，便宜量又足）。</li><li>在VPS上创建CentOS 7系统，安装Shadowsocks服务端，设置并开启Shadowsocks服务。</li><li>在macOS上安装Shadowsocks客户端，设置并使用。</li><li>为了全速利用带宽，购买tcpspeed，在CentOS上安装服务端，并在macOS上开启tcpspeed加速。</li><li>编写Python脚本，简化tcpspeed的启动步骤。</li></ol><h2><span id="vultr-shadowsocks-tcpspeed-fen-bie-shi-shi-me">Vultr + Shadowsocks + tcpspeed 分别是什么？</span></h2><p>Vultr是一个VPS租用商，提供了8个套餐，如下：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498838075955.png" alt="Alt text"></p><p>Shadowsocks是一个基于Socks5的代理工具，分为服务端和客户端工具。</p><p><a href="http://www.tcpspeed.com/" target="_blank" rel="noopener">tcpspeed</a>是一个加速方案，能使Shadowsocks最大限度地利用带宽，用官方说法，优势如下：</p><ol><li>速度更快,延迟更短，摆脱tcp协议先天局限性，可以最大限度利用带宽，速度为单边加速2-30倍。</li><li>稳定性更好，抗干扰能力更强，在高丢包,延迟环境下，单边加速下降到几百KB每秒，而TCPSpeed仍然能满速运行。</li><li>响应更迅速，瞬间加载图片，音乐，视频。</li></ol><h2><span id="kai-xiao">开销</span></h2><p>目前本人使用该组合方案近2年的时间，体验下来速度非常快，花费如下：</p><ol><li>VPS选用的Vultr家的，<strong>5美金/月</strong>。</li><li>tcpspeed是一个加速工具，作者常年打折促销，<strong>159元（一次性消费）</strong>购买1个激活码。1个激活码用于1台服务器，不限客户端数量，更换ip，重装系统，更换服务器只需用原激活码重新激活即可继续使用，可以多次使用部署。</li></ol><p>选择VPS的目的还有一个，可以在上面搭建各种好玩的项目，码农闲不住，就喜欢折腾Hello world~</p><h2><span id="vultr-jia-de-vps">Vultr家的VPS</span></h2><h3><span id="zhu-ce-vultr-zhang-hao">注册Vultr账号</span></h3><p>点击进入<a href="http://www.vultr.com/?ref=6859961" target="_blank" rel="noopener">无敌好用便宜量足的Vultr</a>，在Email Address和Password中分别填入邮箱和密码，然后点Create Account创建账号，如下图所示：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498839232705.png" alt="Alt text"></p><p>然后去邮箱中确认校验地址，如图所示：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498839369178.png" alt="Alt text"></p><p>注册好账号后，进入到Servers界面，然后创建一个服务节点：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498839935196.png" alt="Alt text"></p><p>选择日本节点：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840003589.png" alt="Alt text"></p><p>选择CentOS系统：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840022428.png" alt="Alt text"></p><p>选择$5/月的套餐：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840051424.png" alt="Alt text"></p><p>其他的都不用勾选，点击Deploy Now，租用VPS的步骤就搞定了，将会在Server中看到一个服务节点：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498840174534.png" alt="Alt text"></p><p>点击进去，查看IP地址和密码：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498908581261.png" alt="Alt text"></p><p>假设你的查看到的IP地址是45.63.12.11使用终端工具远程登录服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh root@45.63.12.11</span></span><br><span class="line">root@45.63.12.11<span class="string">'s password:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入你查看到的Vultr密码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@vultr ~]#</span></span><br></pre></td></tr></table></figure></p><p>当你看到[root@vultr ~]#时，说明已经登录成功。</p><p>接下来可以使用命令安装Shadowsocks：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install python-setuptools &amp;&amp; easy_install pip</span></span><br><span class="line"><span class="comment"># pip install shadowsocks</span></span><br></pre></td></tr></table></figure></p><p>安装成功后，就可以配置shadowsocks的相关配置了，主要为Shadowsocks密码，假设设置为12345678（<strong>自己随意改</strong>），如下图所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi /etc/shadowsocks.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>:8989,</span><br><span class="line">    <span class="string">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:1080,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"12345678"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:300,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="string">"fast_open"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置完后，服务端的Shadowsocks就算是搭建并部署好了，接下来在macOS上安装Shadowsocks客户端。</p><h2><span id="macos-shang-an-zhuang-shadowsocks-ke-hu-duan">macOS上安装Shadowsocks客户端</span></h2><p>下载<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">Shadowsocks客户端</a>，打开服务器设定：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910064168.png" alt="Alt text"></p><p>前面假设过你租用的VPS日本节点IP为45.63.12.11，这个以你实际租用IP地址为准，密码为Vultr上Shadowsocks配置的12345678，新增如下配置：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499007746198.png" alt="Alt text"></p><p>然后点击mac导航栏上的Shadowsocks，选中新增的配置：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499007946797.png" alt="Alt text"></p><p>这些都配置完后，就可以打开浏览器试试油管是否可以打开了：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499008111451.png" alt="Alt text"></p><p>可爱的油管出现啦~<br>但现在的带宽利用率还未发掘到最大，接下来使用tcpspeed将带宽利用最大化。</p><h2><span id="tcpspeed-gou-mai-vultr-fu-wu-duan-bu-shu">tcpspeed购买 + Vultr服务端部署</span></h2><p><a href="http://tcpspeed.com/" target="_blank" rel="noopener">tcpspeed注册和购买，自己去完成吧，很简单~</a></p><p>假设已购买好，会看到如下所示的页面：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499009961669.png" alt="Alt text"></p><p>继续在vultr远程终端上安装tcpspeed工具：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm -f install_tcpspeed.sh ; wget http://www.tcpspeed.com/tcpspeed/install_tcpspeed.sh ; chmod +x install_tcpspeed.sh ; ./install_tcpspeed.sh 2&gt;&amp;1 | tee install.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sh /xs/dactivate.sh 激活码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sh /xs/start.sh</span></span><br></pre></td></tr></table></figure></p><p>再给tcpspeed工具添加一个每晚3点自动重启的定时器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crontab -e</span></span><br><span class="line">0 3 * * * sh /xs/restart.sh</span><br></pre></td></tr></table></figure></p><h2><span id="hui-dao-macos-she-zhi-tcpspeed-ke-hu-duan">回到macOS设置tcpspeed客户端</span></h2><p>添加配置如下：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499002937262.png" alt="Alt text"></p><p>其中密码为之前设置的12345678。</p><p>然后选中它：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499008861444.png" alt="Alt text"></p><p>下载<a href="http://www.tcpspeed.com/tcpspeed/tcpspeed_client3.2.zip" target="_blank" rel="noopener">tcpspeed客户端</a>，将其放置在Applications中：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910319354.png" alt="Alt text"></p><p>创建tcpspeed文件，将以下代码黏贴进去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cd</span>:</span></span><br><span class="line">    <span class="string">"""Context manager for changing the current working directory"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, newPath)</span>:</span></span><br><span class="line">        self.newPath = os.path.expanduser(newPath)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.savedPath = os.getcwd()</span><br><span class="line">        os.chdir(self.newPath)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        os.chdir(self.savedPath)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> cd(<span class="string">"/Applications/tcpspeed_client"</span>):</span><br><span class="line">    os.system(<span class="string">"sudo java -jar tcpspeed_client.jar"</span>)</span><br></pre></td></tr></table></figure></p><p>将tcpspeed文件移至/usr/local/bin中，将该文件改为可执行文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 755 tcpspeed</span></span><br></pre></td></tr></table></figure></p><p>在终端中输入命令运行tcpspeed:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tcpspeed</span></span><br><span class="line"></span><br><span class="line">填写密码</span><br></pre></td></tr></table></figure></p><p>注意：运行tcpspeed需要sudo，所以要填写密码。<br>如果你不怕安全问题，可以在Python脚本中填入系统登录密码，这样就不用每次运行tcpspeed时输入密码了。<br>可以直接把最后一句话改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">"echo 'macOS系统登录密码' | sudo -S java -jar tcpspeed_client.jar"</span>)</span><br></pre></td></tr></table></figure></p><p>设置tcpspeed：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910991989.png" alt="Alt text"><br><img src="/2017/07/02/使用Shadowsocks科学上网/1498910977838.png" alt="Alt text"></p><p>接下来就可以打开油管看视频啦，1080P 毫无压力，秒开高清视频：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499003403532.png" alt="Alt text"></p><p>开心的造起来吧，tumblr上资源多，啊哈哈，譬如用强大的Google搜索：<br><img src="/2017/07/02/使用Shadowsocks科学上网/1499008746597.png" alt="Alt text"></p><p>DONE~!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jian-jie&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#zhi-shi-dian&quot;&gt;知识点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vultr-shadow
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-初识ARKit</title>
    <link href="http://fanwt.com/2017/06/29/iOS-%E5%88%9D%E8%AF%86ARKit/"/>
    <id>http://fanwt.com/2017/06/29/iOS-初识ARKit/</id>
    <published>2017-06-29T02:29:53.000Z</published>
    <updated>2017-06-30T02:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#chu-shi-arkit">初识ARKit</a><ul><li><a href="#jia-gou-tu">架构图</a></li><li><a href="#chang-jing-shi-bie">场景识别</a><ul><li><a href="#ping-mian-jian-ce-plane-detection">平面检测（Plane detection）</a></li><li><a href="#peng-zhuang-ce-shi-hit-testing">碰撞测试（Hit-testing）</a></li><li><a href="#gao-guang-gu-suan-light-estimation">高光估算（Light Estimation）</a></li></ul></li><li><a href="#demo">Demo</a><ul><li><a href="#guan-fang-3d-fei-ji-mo-xing-ar-ti-yan">官方3D飞机模型AR体验</a></li></ul></li><li><a href="#zong-jie">总结</a></li></ul></li></ul><!-- tocstop --><p></div></p><h1><span id="chu-shi-arkit">初识ARKit</span></h1><p>Apple在2017WWDC发布会上带来了全新的iOS11，其中最令人瞩目的是引入了ARKit，这是一个新框架，可以让开发者轻松创建无与伦比的iPhone和iPad增强实现体验。通过将虚拟场景与周围的环境融合，ARKit将应用程序超越屏幕，让它们以全新的方式与现实世界进行交互。</p><h2><span id="jia-gou-tu">架构图</span></h2><p>用一张图来展示ARKit框架在应用架构中所处在的位置和功能说明：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-1" alt="ARKit框架在应用架构中所处的位置"></p><p>从上图可知，Apple提供的AR平台底层主要分为2部分：数据分析处理和渲染。<br>ARKit负责数据分析处理，生成AR体验必要的支撑数据，渲染部分Apple提供了3个框架来支持，它们分为两部分：<br>标准渲染视图：SceneKit和SpriteKit，前者提供3D渲染支持，后者提供2D渲染支持。<br>自定义渲染视图：如果觉得Apple提供的标准渲染视图不满足自己的需求，Apple提供了Metal自定义渲染视图框架，来支持自定义渲染视图。</p><p>再来看看ARKit的架构图：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-2" alt="ARKit框架图"></p><p>从上图可知，ARKit框架底层主要功能为追踪，分为2块：摄像头画面实时捕捉视频帧；设备感应硬件检测到的动作数据。<br>ARKit将这2者的数据结合起来分析，生成最终结果，再配合渲染库将2D和3D元素内容实时的显示到用户设备实时的摄像画面中，能使用户体验到AR的错觉乐趣，这些2D或3D元素内容从画面中看上去就像是真实世界中的一部分。</p><p>架构图看完后，再看看ARKit数据处理的主要流程图：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-3" alt="ARKit数据处理流程图"></p><p>从上图流程图中可知，ARKit的核心是ARSession，它管理着AVCaptureSession和CMMotionManager。<br>AVCaptureSession是AVFoundation的核心类，主要用于捕捉视频和音频，协调视频和音频的输入、输出流。<br>CMMotionManager是用于对设备运动识别的，它有2种采样方式：</p><p>PUSH：实时采集所需数据，采样频率高。<br>PULL：在有需要的时候，才去采集数据。<br>要运行一个Session，必须要传入一个ARSessionConfiguration配置，运行中的Session会连续地从AVCaptureSession中捕获实时的摄像画面，再结合CMMotionManager提供的运动数据，最终预测出设备的实际位置。</p><h2><span id="chang-jing-shi-bie">场景识别</span></h2><p>Apple在WWDC大会上展示了ARKit强大的场景识别能力，视频中有两个让人印象特别深刻的地方：<br>1.演讲者使用一个iPhone手机演示将一个逼真的AR战地场景展示在现场桌面上，其中一个小人为了躲避飞机扔下的炮弹，从桌上跳了下去，刚开始以为这仅仅是WWDC现场演示时Demo故意给人错觉的一种演讲效果，但后来回看了下官方文档，确实有提及ARKit是可以捕捉到多个平面的，以及在后来的演示中有看到DEBUG工具展示多个平面网格。<br>2.另一个<a href="https://developer.apple.com/videos/play/wwdc2017/609/" target="_blank" rel="noopener">SpriteKit大会讲解视频</a>(PS:在视频24分)时，视频中游戏演示的小人跳到了桌面上的平层，能够在真实世界的平层上来回走动，是不是很震惊！！！</p><p>从官方的PPT上看到ARKit在场景识别中有3项重要的技术，分别是：</p><ul><li>平面检测（Plane detection）</li><li>碰撞测试（Hit-testing）</li><li>亮度估量（Light estimation）</li></ul><h3><span id="ping-mian-jian-ce-plane-detection">平面检测（Plane detection）</span></h3><p>PPT中概括了4点：</p><ol><li>能检测到相对于重力的水平面，即它能检测的出平面的高低落差层次。</li><li>可以运行多个帧，如果没理解错的话，应该就是可以同时分析检测出多个平面。</li><li>可以对齐置平面的表面上，即当你放置3D精灵视图时，能自动的将3D精灵视图平放到对应的平面上，使它看上去就是像现实中物体放在平面上一样。</li><li>进行平面合并。</li></ol><p>上述可能不是很好理解，用一张图来概括：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-4" alt="ARKit数据处理流程图"></p><p>开启平面检测很方便，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable plane detection on a session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new world tracking configuration</span></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingSessionConfiguration</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable plane detection</span></span><br><span class="line">configuration.planeDetection = .horizontal</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change configuration on currently running session</span></span><br><span class="line">mySession.run(configuration)</span><br></pre></td></tr></table></figure></p><p>ARWorldTrackingSessionConfiguration类是ARSessionConfiguration类的子类。<br>翻看官方文档可知：<br>ARSessionConfiguration类提供3个自由度（DOF）追踪设备的运动：具体来说，三个旋转轴（滚动，俯视和偏航），它支持所有iOS设备上使用ARKit。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-12" alt="ARSessionConfiguration 3DOF"></p><p>ARWorldTrackingSessionConfiguration类是AR体验增强类，对iOS设备要求比较高，需要CPU不低于A9，也就是目前市面上最低iPhone 6s，它提供6个自由度（DOF）追踪设备的运动，比其父类多了3个自由度：三个坐标系（在x、y、z轴上运动）。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-13" alt="ARWorldTrackingSessionConfiguration 6DOF"></p><h3><span id="peng-zhuang-ce-shi-hit-testing">碰撞测试（Hit-testing）</span></h3><p>PPT中概括了4点：</p><ol><li>使用真实世界的相交射线。</li><li>使用场景信息。</li><li>结果按照远近距离排序。</li><li>有4种碰撞测试类型来帮助判断碰撞测试结果。</li></ol><p>Hit-testing会去检测分析出相机图像中的水平面，然后生成其位置和大小的数据。可以把它想象为，摄像头发射一个射线出去，射线碰撞检测到一个点，那么收集到足够多的点就能分析出平面，最终生成返回数据。</p><p>如图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-9" alt="Hit-testing"></p><p>基于Hit-testing建立一个锚点，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding an ARAnchor based on hit-test</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="type">CGPoint</span>(x:<span class="number">0.5</span>, y:<span class="number">0.5</span>) <span class="comment">// Image center</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform hit-test on frame</span></span><br><span class="line"><span class="keyword">let</span> results = frame.hitTest(point, types:[.existingPlane, .estimatedHorizontalPlane])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the first result</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> closestResult = results.first &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an Anchor for it</span></span><br><span class="line"><span class="keyword">let</span> anchor = <span class="type">ARAnchor</span>(transform: closestResult.worldTansform)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add it to the session</span></span><br><span class="line">session.add(anchor: anchor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ARSKView、ARSCNView、ARFrame类中提供了hitTest方法，用于碰撞测试检测分析出平面，方法返回一组ARHitTestResult对象，该方法传入2个参数，第一个参数为CGPoint点，第二个参数为检测碰撞结果的类型，有4种：</p><ol><li>ARHitTestResult.ResultType.featurePoint，根据距离最近的特征点检测出来的连续表面。</li><li>ARHitTestResult.ResultType.estimatedHorizontalPlane，非精准方式计算出来与重力垂直的平面。</li><li>ARHitTestResult.ResultType.existingPlane，已经检测出来的平面，检测时忽略平面本身大小，把它看做一个无穷大的平面。</li><li>ARHitTestResult.ResultType.existingPlaneUsingExtent，已经检测出来的平面，检测时考虑平面本身的大小。<br>这4种类型可以用|来同时传入。</li></ol><h3><span id="gao-guang-gu-suan-light-estimation">高光估算（Light Estimation）</span></h3><p>在AR增强视觉体验中，如果虚拟内容的高光与环境不符，那还是挺容易看得出这就是一个虚拟物体的。<br>ARKit提供来一个检测视频图像环境光照强度的功能，主要是为了让3D模型的光照与环境的光照强度保持一致。<br>ARKit默认开启了这项检测，且流明度默认值为1000。</p><p>用图来展示ARKit强大的魅力：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-7" alt="Light Estimation 1"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-8" alt="Light Estimation 2"></p><h2><span id="demo">Demo</span></h2><h3><span id="guan-fang-3d-fei-ji-mo-xing-ar-ti-yan">官方3D飞机模型AR体验</span></h3><p>在Xcode9 beta1中，官方在模板工程中提供了2个示例：SceneKit和SpriteKit，前者3D，后者2D。<br>在Xcode9 beta2中，官方在模板工程中又新增了1个Metal的示例，可以使用Metal技术来自定义渲染视图，该种实现方式比SceneKit和SpriteKit这两种方式复杂的多，<a href="https://developer.apple.com/documentation/arkit/displaying_an_ar_experience_with_metal" target="_blank" rel="noopener">具体细节请参阅官方文档</a>。</p><p>你可以新建一个工程，选择AR模版，在Content Technology中选择使用SceneKit或SpriteKit或Metal，这里选用SceneKit。<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-10" alt="Demo 1"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-11" alt="Demo 1"></p><p>模板工程很简单，如下图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-14" alt="Demo 1"></p><p>art.scnassets为AR素材资源目录，官方提供了一个飞机建模：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-15" alt="Demo 1"></p><p>ViewController.swift中的代码如下（删去了暂时无用的空代理回调方法）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the view's delegate</span></span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">        sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new scene</span></span><br><span class="line">        <span class="keyword">let</span> scene = <span class="type">SCNScene</span>(named: <span class="string">"art.scnassets/ship.scn"</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the scene to the view</span></span><br><span class="line">        sceneView.scene = scene</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a session configuration</span></span><br><span class="line">        <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingSessionConfiguration</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the view's session</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pause the view's session</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码解读：</p><ol><li>渲染模块使用ARSCNView视图，它支持3D模型渲染。</li><li>在viewDidLoad中设置sceneView的代理，以及现实FPS状态，然后加载飞机3D模型，并将其设置为sceneView的scene属性。</li><li>view即将展现时，配置一个ARWorldTrackingSessionConfiguration对象（支持6DOF），将使用该配置来运行Session。</li><li>view即将消失时，暂停Session的运行。</li></ol><p>当你使用A9+设备运行该工程时，会在摄像画面的水平正前方出现一架飞机3D模型，可以像正常拍摄一个物体一样360度查看它，如下图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-16.gif" alt="ARKit-SceneKit-Demo"></p><p>简简单单的几行代码便将一个飞机3D模型实时渲染到了实时的视频画面中，还支持6轴运动，不得不说ARKit将AR门槛降低了非常多，使得开发者很轻松地创建出AR体验APP。</p><p>官方提供了一个<a href="https://developer.apple.com/sample-code/wwdc/2017/PlacingObjects.zip" target="_blank" rel="noopener">较为复杂的ARDemo</a>，可以放置一些家具的，画面很逼真，并提供了DEBUG的工具来帮助开发者理解ARKit相关特性，如图所示：<br><img src="/2017/06/29/iOS-初识ARKit/ARKit-17" alt="ARKit-SceneKit-Demo"><br><img src="/2017/06/29/iOS-初识ARKit/ARKit-18.gif" alt="ARKit-SceneKit-Demo"></p><h2><span id="zong-jie">总结</span></h2><p>ARKit支持所有的设备，在CPU A9以下的设别，提供基础的3DOF（滚动，俯视和偏航）支持，在CPU A9及以上，提供6DOF（滚动，俯视和偏航，以及三个坐标系（在x、y、z轴上运动））支持。</p><p>ARKit提供了强大的数据分析能力，将实时画面帧与设备运行数据结合，为开发者创建无比惊艳的AR体验APP提供了强大的数据支撑。要开发AR体验APP，需要开发者具备以下知识：</p><ol><li>线性代数-矩阵计算，推荐一个视频：<a href="http://www.bilibili.com/video/av6731067/" target="_blank" rel="noopener">线性代数的本质 - 系列合集</a>。</li><li>熟悉ARKit框架。</li><li>熟悉SceneKit、SpriteKit，这是Apple提供的标准渲染视图，内部处理了绝大部分的渲染处理，能帮助开发者降低渲染AR所具备的知识。</li><li>如果要自定义渲染，可以使用Apple提供的Metal框架，今年会发布Metal2，性能进一步提升。</li></ol><p>可以预测到iOS11正式发布时，将会有众多应用会借势ARKit上首推，特别是游戏类APP，譬如以前大火的植物大战僵尸、水果忍者、宠物精灵、飞行游戏、养成类游戏等等，一般应用中大多数是活动场景，好比：AR抢红包、寻宝、展示等等。</p><p>目前正处于Beta阶段的AR体验还有待改进，真机体验的时候，还是能很明显的感受到虚拟物品会漂移或不自然的抖动，慢慢静待Apple的修正吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#chu-shi-arkit&quot;&gt;初识ARKit&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jia-gou-tu&quot;&gt;架构图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chang
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS - 按纯色行切页</title>
    <link href="http://fanwt.com/2017/03/28/iOS-%E6%8C%89%E7%BA%AF%E8%89%B2%E8%A1%8C%E5%88%87%E5%88%86%E9%A1%B5/"/>
    <id>http://fanwt.com/2017/03/28/iOS-按纯色行切分页/</id>
    <published>2017-03-28T02:00:48.000Z</published>
    <updated>2017-03-28T02:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>当前从事阅读类产品开发，开发过程中遇到产品需要在阅读渲染页加各种与阅读正文无关的一些增强用户粘性需求，好比添加：章评、段评、打赏等酷炫的界面。</p><p>开发过程中又需要解耦模块，不希望这个新增的页面影响到阅读渲染本身，我这里有一种尝试思路，如有问题希望轻拍。</p><p>PS：目前还未运用到实际项目中，只是一个解耦的想法而已💡</p><h2><span id="jie-jue-si-lu">解决思路</span></h2><ol><li>如何解决在已渲染好的阅读页中动态加入自定义页，不影响阅读页排版功能，不侵入阅读代码？<br>答：假设自定页面只有一页，且高度就是该阅读页正文显示完剩余的区域，那么直接将自定义页面以addSubView的形式加入到该阅读页。</li><li>当自定义页超过一屏时，如何尽可能小影响或不影响阅读翻页逻辑？<br>答：前提：目前我们的阅读框架中每页是否有下一页是一个动态询问过程，翻页手势会询问容器中的当前页是否有前、后一页。修改点：询问逐层传递的思想，修改后，阅读页中有自定义子页时，应优先询问子页是否有下一页，如果有，下一页显示自定义子页，如果没有，再看阅读页自身是否有下一页。</li></ol><h2><span id="he-xin-ru-he-qie-ye">核心：如何切页</span></h2><p>自定义页面转为像素data，注意不要用高清，节省内存，给一个起始锚点，逐行扫描，当遇到色值不一样时，换行。<br>代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    eFindPureSeparateLinePointDirection_down = <span class="number">0</span>,</span><br><span class="line">    eFindPureSeparateLinePointDirection_up</span><br><span class="line">&#125;eFindPureSeparateLinePointDirection;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">WtExt</span>)</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)wt_findPureSeparateLinePointWithAnchor:(<span class="built_in">CGPoint</span>)point direction:(eFindPureSeparateLinePointDirection)direction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">WtExt</span>)</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)wt_findPureSeparateLinePointWithAnchor:(<span class="built_in">CGPoint</span>)point direction:(eFindPureSeparateLinePointDirection)direction &#123;</span><br><span class="line">    <span class="keyword">int</span> preR = <span class="number">-1</span>, preG = <span class="number">-1</span>, preB = <span class="number">-1</span>, preA = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    size_t pixelsWidth = <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.frame);</span><br><span class="line">    size_t pixelsHeight = <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.frame);</span><br><span class="line">    <span class="keyword">int</span> x = point.x;</span><br><span class="line">    <span class="keyword">int</span> y = point.y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> scale = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.frame.size.width*scale, <span class="keyword">self</span>.frame.size.height*scale) ;</span><br><span class="line">    <span class="keyword">int</span> bitPerRow = size.width * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> bitCount = bitPerRow * size.height;</span><br><span class="line">    <span class="built_in">UInt8</span> *bitdata = malloc(bitCount);</span><br><span class="line">    <span class="keyword">if</span> (bitdata == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> deviceRGB = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="keyword">if</span> (deviceRGB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRef</span> contex = <span class="built_in">CGBitmapContextCreate</span>(bitdata, size.width, size.height, <span class="number">8</span>, bitPerRow, deviceRGB, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    <span class="keyword">if</span> (contex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(deviceRGB);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(<span class="number">-1</span>, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(deviceRGB);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(contex, <span class="number">0</span>, size.height);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(contex, scale, -scale);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.layer renderInContext:contex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = (direction==eFindPureSeparateLinePointDirection_down)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &gt;= pixelsHeight || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">-1</span>;</span><br><span class="line">            y = INT_MAX;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= pixelsWidth) &#123;</span><br><span class="line">            x = point.x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">4</span>*((pixelsWidth*round(y))+round(x));</span><br><span class="line">        <span class="keyword">if</span> (preR == <span class="number">-1</span>) &#123;</span><br><span class="line">            preR = bitdata[offset];</span><br><span class="line">            preG = bitdata[offset+<span class="number">1</span>];</span><br><span class="line">            preB = bitdata[offset+<span class="number">2</span>];</span><br><span class="line">            preA = bitdata[offset+<span class="number">3</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (preR != bitdata[offset] ||</span><br><span class="line">                preG != bitdata[offset+<span class="number">1</span>] ||</span><br><span class="line">                preB != bitdata[offset+<span class="number">2</span>] ||</span><br><span class="line">                preA != bitdata[offset+<span class="number">3</span>]) &#123;</span><br><span class="line"></span><br><span class="line">                x = point.x;</span><br><span class="line">                y += i;</span><br><span class="line">                preR = <span class="number">-1</span>, preG = <span class="number">-1</span>, preB = <span class="number">-1</span>, preA = <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contex);</span><br><span class="line">    free(bitdata);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当前从事阅读类产品开发，开发过程中遇到产品需要在阅读渲染页加各种与阅读正文无关的一些增强用户粘性需求，好比添加：章评、段评、打赏等酷炫的界面。&lt;/p&gt;
&lt;p&gt;开发过程中又需要解耦模块，不希望这个新增的页面影响到阅读渲染本身，我这里有一种尝试思路，如有问题希望轻拍。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS - 路由解耦</title>
    <link href="http://fanwt.com/2017/03/25/iOS-JSSDK/"/>
    <id>http://fanwt.com/2017/03/25/iOS-JSSDK/</id>
    <published>2017-03-25T06:09:42.000Z</published>
    <updated>2017-03-25T06:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#lu-you-jie-ou-shi-sha">路由解耦是啥？</a></li><li><a href="#lu-you-jie-ou-neng-jie-jue-shi-me">路由解耦能解决什么？</a></li><li><a href="#ji-zhu-xu-qiu-bei-jing">技术需求背景</a></li><li><a href="#zheng-li-ji-zhu-shi-xian-si-lu">整理技术实现思路</a></li><li><a href="#yi-hybrid-jssdk">一、Hybrid(JSSDK)</a><ul><li><a href="#hybrid-jssdk-de-shi-yong-chang-jing-ji-url-ju-li">Hybrid(JSSDK)的使用场景及URL举例</a></li></ul></li><li><a href="#er-openurl">二、OpenURL</a><ul><li><a href="#openurl-yu-dao-de-keng">OpenURL遇到的坑</a></li><li><a href="#openurl-de-shi-yong-chang-jing-ji-url-ju-li">OpenURL的使用场景及URL举例</a></li></ul></li><li><a href="#san-universal-links">三、Universal Links</a><ul><li><a href="#universal-links-de-shi-yong-chang-jing-ji-url-ju-li">Universal Links的使用场景及URL举例</a></li></ul></li><li><a href="#shi-xian-yao-dian">实现要点</a><ul><li><a href="#jie-xi-url-de-ru-kou">解析URL的入口</a></li><li><a href="#jie-xi-hou-de-zi-duan-zuo-lu-you-zhuan-fa">解析后的字段作路由转发</a></li></ul></li><li><a href="#wei-wan-dai-xu">未完待续</a></li></ul><!-- tocstop --></div><h2><span id="lu-you-jie-ou-shi-sha">路由解耦是啥？</span></h2><p>路由解耦，故名思意就是使用URL，根据请求地址进行解析，映射到相关代码的逻辑操作，诸如：页面跳转、UI弹层展示、事件分发、IO存储等等，对于调用方来说，使用统一标准化格式的URL协议即可。<br>在iOS端的开发中，使用URL交互的地方无外乎：应用内Web、应用外Web、应用模块间解耦单向通信（双向通信使用模块暴露接口会更佳合理和优雅），本文将从Hybrid(JSSDK)、OpenURL(iOS9-)、Universal Links(iOS9+)三方面阐述路由解耦设计的一些经验和思考。</p><h2><span id="lu-you-jie-ou-neng-jie-jue-shi-me">路由解耦能解决什么？</span></h2><ol><li>应用内Web，使用封装的Hybrid(JSSDK)进行双向通信。</li><li>应用外Web，会受到制约：有的APP比较强势，会拦截URL，不允许跳转到外部应用，例如：微信。iOS8目前仍无解(用户占比少)，但iOS9+(用户占比极高)的设备可以使用Universal Links来解决该问题。</li><li>应用模块间解耦单向通信，相当于给模块暴露的单向通信接口起一个URL的别名，好处是方便业务部门的人来使用，例如：活动配置，下发URL可以跳转到相应的页面。</li></ol><h2><span id="ji-zhu-xu-qiu-bei-jing">技术需求背景</span></h2><ol><li>在早期的iOS开发中，经常需要会遇到调用或跳转外部其他App，诸如：在关于联系我们页面中的电话点击事件触发后直接拨打电话、点击email时弹出发送邮件页（预设好接受人email、主题、内容等）、跳转到Apple的设置页、跳转到Sina微博分享等等，Apple在iOS2.0时提供了OpenURL解决方案来支持上述的需求场景。</li><li>项目中有很多活动相关的Web页，在Web页面中常常需要获取客户端的信息、调用客户端的原生功能，诸如：获取客户端版本号、打开客户端的原生页面、修改导航栏色值、调用客户端的本地逻辑操作等。</li><li>在微信这种强势APP中，OpenURL被它拦截，导致无法跳转自己的APP 的相关功能页。</li><li>由于OpenURL的过程没有任何安全性校验，导致APP内支持的OpenURL可能会被任何的App随时呼起，以及滥用其中的功能。Apple考虑到OpenURL安全性不足，于是在iOS9中推出了Universal Links(通用链接)和ATS 隐私控制，不在AASA、ATS白名单的域名统统被拒绝。我们工程最低版本支持iOS8+，Web页在iOS8的设备上能通过OpenURL唤起APP，但iOS9+后，由于未配置Universal Links，导致OpenURL失效，最终无法唤起APP。</li></ol><h2><span id="zheng-li-ji-zhu-shi-xian-si-lu">整理技术实现思路</span></h2><p>Hybrid(JSSDK)、OpenURL、Universal Links三者都是使用URL统一资源定位符来与客户端通信，这三者的通性，利用这一点，只要URL统一规则，客户端就可以无差别的解析处理了。<br>格式定义如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://module:port/method?&#123;query:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p><ol><li>关于scheme，Hybrid(JSSDK)、OpenURL、Universal Links可以使用一致的scheme，一般而言，scheme统一使用项目的scheme即可。Hybrid(JSSDK)使用了scheme为jsbridge来区分这是JSSDK的API。</li><li>port，解析后，只有Hybrid(JSSDK)会使用该参数进行OC与JS通信，实现原理很简单，JS提供一个回调方法，port参数用于告知是哪一个事件回调了，就像设置了一个delegate。OpenURL、Universal Links只能URL-&gt;客户端的单向通信，无法回传数据给调用方，即无法使用、也不需要port参数。</li><li>module，模块，映射到客户端的哪个模块。</li><li>method，方法，映射到客户端的哪个模块的哪个方法。</li><li>query，参数，映射到客户端的哪个模块的哪个方法中的参数。</li></ol><p>不同的iOS版本、应用内、应用外，使用的安全处理机制不一样，解决方案如下：</p><ol><li>iOS8设备，Hybrid(JSSDK) 有自己单独的域名白名单，可以监管到安全问题；OpenURL可以随意调用，无法监管到安全问题。</li><li>iOS9+设备，Hybrid(JSSDK) 有自己单独的域名白名单，可以监管到安全问题；应用内HTTP、Web由ATS监管安全问题；Universal Links使用配置的apple-app-site-association来监管安全问题。<blockquote><p><strong>注意：如果开启了ATS功能，iOS9和iOS10还是有些区别的，iOS9中的ATS没有区分本地请求和Web请求，iOS10中考虑到Web无法全部使用ATS的场景，所以如果在项目中开启了ATS并设置了NSExceptionDomains白名单以及开启了NSAllowsArbitraryLoadsInWebContent字段为true，那在iOS9应用内Web会验证白名单，而iOS10应用内Web不会验证白名单，直接使用NSAllowsArbitraryLoadsInWebContent允许全部的web关闭ATS验证。当前iOS端主流最低支持版本为iOS8+，这就需要和客户端合作的Web前端同学注意资源域名要在白名单中才能兼容iOS9的设备Web正常访问资源。</strong></p></blockquote></li></ol><h2><span id="yi-hybrid-jssdk">一、Hybrid(JSSDK)</span></h2><p>关于JSSDK，核心技术有以下几点：</p><ol><li><p>URL的协议定义，上述讲了，为了避免上翻回去查找，这里再贴一次，格式为：</p><blockquote><p>scheme://module:port/method?{query:{}}</p></blockquote></li><li><p>使用OC的动态性、以及使用block回调，动态查找类、方法，动态调用方法，动态传入参数，动态性+block的组合很完美。</p></li><li>利用port字段，在OC回调JS方法时传入，作为delegate使用，这样就支持了OC与JS的双向通信能力。<br>实际编码过程中，JSSDK的核心代码量不超过100行，是不是特别简单容易理解。</li></ol><h3><span id="hybrid-jssdk-de-shi-yong-chang-jing-ji-url-ju-li">Hybrid(JSSDK)的使用场景及URL举例</span></h3><p>举例双向通信和单向通信，栗子来了：<br>使用场景如下：</p><ol><li><p>Web页调用JS获取客户端的信息，通过port端口号回调JS方法，好比：获取客户端的VersionCode，如下代码所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向通信</span></span><br><span class="line">jsbridge:<span class="comment">//device:1/versionCode</span></span><br></pre></td></tr></table></figure></li><li><p>Web页调用JS设置导航栏右侧按钮，点击按钮后，通过port端口号回调JS方法，好比：设置Web页导航栏右侧按钮为分享，如下代码所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向通信</span></span><br><span class="line">jsbridge:<span class="comment">//ui:2/setHeaderRight?&#123;"query":&#123;"icon":"share"&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>应用内Web页的JS -&gt; OC 单向通信，好比：Web页中点击封面跳转客户端原生书籍详情页：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向通信</span></span><br><span class="line">jsbridge:<span class="comment">//app/showBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="er-openurl">二、OpenURL</span></h2><p>OpenURL设计的目的就是解耦模块，我们来看看它能做什么：</p><ol><li>Apple就提供了若干的功能，诸如：打电话、发邮件、打开AppStore等。</li><li>常见的第三方登录模块也用的OpenURL来进行APP间跳转式的双向通信。</li><li>APNS推送中可以添加字段URL，用户点击推送后，可以执行相应逻辑，这里能很清楚地看得到模块间的解耦。</li><li>桌面APP使用3D Touch时，可以用OpenURL的思路解决模块解耦问题，在设置3D Touch项时，使用OpenURL作为item的描述，这样3D Touch回调事件里只需写一句话：执行OpenURL。</li></ol><h3><span id="openurl-yu-dao-de-keng">OpenURL遇到的坑</span></h3><p>实际使用过程中，我发现Apple的OpenURL效率并不高，在某些场景下速度慢的惊人，譬如上述它能做什么中的第4点，如果在3D Touch回调中直接使用Apple的OpenURL方法，真机上看到的现象是进入APP奇慢无比，像是卡住了一样。3D Touch回调事件代码如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *urlString = shortcutItem.type;</span><br><span class="line">    <span class="keyword">if</span> (urlString.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:[urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法也很简单：<br>其实想想就知道OpenURL是用于APP外部调用的，在我们APP应用内直接走解析URL和动态执行方法就好了。改进后的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *urlString = shortcutItem.type;</span><br><span class="line">    <span class="keyword">if</span> (urlString.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> qd_handleActionUrl:[<span class="built_in">NSURL</span> URLWithString:[urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="openurl-de-shi-yong-chang-jing-ji-url-ju-li">OpenURL的使用场景及URL举例</span></h3><p>使用场景如下：</p><ol><li><p>应用内部调用URL路由作模块解耦，好比：书籍详情页调用加书架功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//app/addToBookshelf?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>APNS推送点击后可以响应客户端本地事件，好比：用户收到了一条热门书籍推送，点击推送后跳转客户端原生书籍详情页：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//app/showBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="san-universal-links">三、Universal Links</span></h2><p>这里讲到它的目的，是以下2点：</p><ol><li>在iOS9+时，Apple提出了ATS的要求，以前的OpenURL在Web前端可以随意被其他APP滥用，没有任何的安全机制保护，于是推出了Universal Links来增加OpenURL在Web前端的安全合法校验，只有域名验证通过的链接，才能使用OpenURL打开APP。</li><li>微信中拦截了URL，不让跳转到外部应用中。但Universal Links是系统级别的，可以绕过微信的拦截限制。</li></ol><p>它和Hybrid(JSSDK)、OpenURL的URL格式有所区别，它的格式如下：<br>PS: 由于Universal Links只作单向通信，所以我们忽略port参数(port参数的目的就是作为双向通信delegate)。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:<span class="comment">//host/route/module/method?&#123;query:&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><p>它的区别在于:它多出来了host/route，除了这一点，其他格式和Hybrid(JSSDK)、OpenURL的URL毫无差别，所以当客户端接收到URL时，过滤掉host/route就可以了。</p><h3><span id="universal-links-de-shi-yong-chang-jing-ji-url-ju-li">Universal Links的使用场景及URL举例</span></h3><p>使用场景如下：</p><ol><li><p>iOS9+在Web前端的链接，好比：书籍详情页调用加书架功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//qidian.com/reader/app/addToBookshelf?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>微信中点击链接打开客户端原生页面， 好比：微信公众号里分享了一本经典小说，点击后跳转打开客户端原生阅读页：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QD:<span class="comment">//qidian.com/reader/app/openBook?&#123;"query":&#123;"bookId": 1004976324&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="shi-xian-yao-dian">实现要点</span></h2><h3><span id="jie-xi-url-de-ru-kou">解析URL的入口</span></h3><p>Hybrid(JSSDK)、OpenURL、Universal Links 3者处理URL入口不一样，具体如下：</p><ol><li><p>Hybrid(JSSDK)在UIWebView的delegate回调中拦截URL进行特殊处理，如果Hybrid(JSSDK)拦截成功，则直接返回NO，打断UIWebView自身的处理逻辑；否则返回YES，继续UIWebView的处理逻辑，方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)webView:shouldStartLoadWithRequest:navigationType:</span><br></pre></td></tr></table></figure></li><li><p>OpenURL，在AppDelegate的回调中处理解析URL，iOS8与iOS9的有所区别，如下所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS9代理回调方法</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)application:openURL:options:</span><br><span class="line"></span><br><span class="line"><span class="comment">//iOS8代理回调方法</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)application:openURL:sourceApplication:annotation:</span><br></pre></td></tr></table></figure></li><li><p>Universal Links，在AppDelegate的回调中处理解析URL，方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要注意一点的是，通用链接过来的URL，会带有host/route，在代理方法中需要过滤掉host/route，将格式统一为scheme://module/method?&#123;query:&#123;&#125;&#125;</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)application:continueUserActivity:restorationHandler:</span><br></pre></td></tr></table></figure></li><li><p>暴露了一个C函数，方便跨模块调用，主要用于解耦目的。目前只支持单向通信（考虑到双向通信会增加复杂度，使用模块对外暴露接口更优雅，所以暂不考虑双向通信）。举例，调用方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QDRouteBridge(<span class="string">@"QDReader://app/addToBookshelf?&#123;\"query\":&#123;\"bookId\": 1004976324&#125;&#125;"</span>)</span><br></pre></td></tr></table></figure></li></ol><h3><span id="jie-xi-hou-de-zi-duan-zuo-lu-you-zhuan-fa">解析后的字段作路由转发</span></h3><p>当成功解析了scheme、port、module、method、query部分后，iOS客户端会通过module映射到一个类名，method映射到其中的一个具体方法，query、port这2个作为传入参数，然后执行该方法。<br>总结关键执行步骤：</p><ol><li>映射到具体的类。</li><li>拼接方法名。</li><li>利用OC语言的动态性，动态调用方法。<br>关键的代码部分：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)qd_handleJsRequest:(<span class="built_in">NSURL</span> *)request module:(<span class="built_in">NSString</span> *)module method:(<span class="built_in">NSString</span> *)method port:(<span class="built_in">NSNumber</span> *)port query:(<span class="built_in">NSDictionary</span> *)query fromEnv:(<span class="built_in">NSDictionary</span> *)env &#123;</span><br><span class="line">    <span class="keyword">if</span> (!request ||</span><br><span class="line">        !module ||</span><br><span class="line">        !method) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"qd_handleJsBridgeRequest_%@_%@:port:"</span>, module, method]);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:selector]) &#123;</span><br><span class="line">        <span class="keyword">id</span>&lt;QDJSWebViewProtocol&gt; webViewController = [env objectForKey:kJSPluginEnvWebViewController];</span><br><span class="line">        <span class="keyword">self</span>.webViewController = webViewController;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSDictionary</span>*, <span class="built_in">NSNumber</span> *))objc_msgSend)(<span class="keyword">self</span>, selector, query, port);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2><span id="wei-wan-dai-xu">未完待续</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lu-you-jie-ou-shi-sha&quot;&gt;路由解耦是啥？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lu-you-jie-ou-neng-jie-jue-shi-me&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
